<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta http-equiv="Permissions-Policy" content="gamepad=(self), clipboard-read=(self)">

    <title>Sticker Sheet Creator</title>
    <!-- External Libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- GIF Encoder -->
    <script src="lib/gif.js"></script>
    
    <!-- Fonts for Stamps (Google Fonts) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Pacifico&family=Permanent+Marker&family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <style>
        /* --- CORE VARIABLES --- */
        :root {
            /* Dimensions */
            --paper-width: 152.4mm;
            --paper-height: 101.6mm;
            --cell-width: 26.6mm;
            --cell-height: 20mm;
            --gap: 1mm;
            --grid-width: calc((var(--cell-width) * 4) + (var(--gap) * 3));
            --grid-height: calc((var(--cell-height) * 4) + (var(--gap) * 3));

            /* Touch & Spacing */
            --touch-target: 44px;
            --touch-target-lg: 48px;
            --touch-target-xl: 56px;
            --spacing-xs: 8px;
            --spacing-sm: 10px;
            --spacing-md: 12px;
            --spacing-lg: 15px;
            --spacing-xl: 20px;

            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
            --radius-pill: 50%;

            /* Button Padding */
            --btn-padding: 10px 24px;
            --btn-padding-sm: 6px 12px;
            --btn-padding-lg: 12px 20px;

            /* Video Rental Palette */
            --bg: #1d2c5e;         /* Deep Blue Main BG */
            --light-blue: #2a4480; /* Intermediary Blue for Containers */
            --text: #ffffff;
            --border: #ffcb05;     /* Video Rental Yellow */
            --accent: #ffcb05;
            --btn-hover: #c7a008;
            --btn-bg: #1d2c5e;     /* Dark button bg */
            --purple-btn: #6f42c1;
            --green-btn: #28a745;
            --red-btn: #dc3545;
        }

        /* --- THEME DEFINITIONS --- */
        [data-theme="video-rental"] { --bg: #1d2c5e; --light-blue: #2a4480; --panel: #1d2c5e; --text: #ffffff; --border: #ffcb05; --accent: #ffcb05; --btn-hover: #c7a008; --btn-bg: #1d2c5e; }
        [data-theme="dark"] { --bg: #1a1e23; --light-blue: #2d333b; --text: #e6e6e6; --border: #444c56; --accent: #444c56; --btn-hover: #444c56; --btn-bg: #373e47; }
        [data-theme="light"] { --bg: #e0e0e0; --light-blue: #ffffff; --text: #333333; --border: #cccccc; --accent: #007bff; --btn-hover: #0056b3; --btn-bg: #f8f9fa; }
        
        /* Updated Retro Theme */
        [data-theme="retro"] { 
            --bg: #01009a; 
            --light-blue: #f5b201; /* Mustard Yellow */
            --panel: #f5b201; 
            --text: #ffffff;       /* Changed to White */
            --border: #e10916; 
            --accent: #329900; 
            --btn-hover: #e10916; 
            --btn-bg: #ffffff; 
        }

        [data-theme="hearts"] { --bg: #FFB6C1; --light-blue: #fff0f5; --text: #8b1a4a; --border: #ff69b4; --accent: #ff1493; --btn-hover: #ff69b4; --btn-bg: #ffffff; }
        [data-theme="vines"] { --bg: #C1FFB6; --light-blue: #e8f5e9; --text: #1a3d18; --border: #4caf50; --accent: #388e3c; --btn-hover: #4caf50; --btn-bg: #ffffff; }
        [data-theme="1-up"] { 
            --bg: #5c94fc; 
            --light-blue: #c84c0c; 
            --panel: #c84c0c; 
            --text: #ffffff; 
            --border: #000000; 
            --accent: #fca044; 
            --btn-hover: #e45c10; 
            --btn-bg: #c84c0c; 
            
            /* Override colors for 1-UP specifically */
            --purple-btn: #c84c0c; 
            --green-btn: #c84c0c; 
            --red-btn: #c84c0c; 
        }

        /* Unified Theme Button Text Color Fixes */
        [data-theme="light"] button,
        [data-theme="light"] .btn-primary { 
            color: #333; 
        }
        /* Removed Retro button override to allow it to inherit white text */
        
        [data-theme="hearts"] button,
        [data-theme="vines"] button { 
            color: var(--text); 
            border-color: var(--border); 
        }
        
        /* Force 1-UP buttons to use theme border and text color (White on Brick Red) */
        [data-theme="1-up"] .btn-purple,
        [data-theme="1-up"] .btn-green,
        [data-theme="1-up"] .btn-delete,
        [data-theme="1-up"] .btn-stamp-add {
            background-color: var(--light-blue);
            color: var(--text);
            border-color: var(--border);
        }

        /* --- GLOBAL STYLES --- */
        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            transition: background-color 0.3s ease;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        h1 { display: none; } 

        .controls {
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- BOX STYLES --- */
        .control-section {
            background: var(--light-blue); 
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* Settings Row */
        .settings-row { display: flex; gap: 20px; flex-wrap: wrap; }
        .setting-group { flex: 1; display: flex; flex-direction: column; gap: 8px; min-width: 150px; }
        .setting-group label { font-weight: 700; font-size: 0.95rem; color: var(--text); }
        select {
            background-color: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 6px;
            font-weight: 500;
            outline: none;
            cursor: pointer;
            width: 100%;
            font-family: inherit;
        }
        option { background-color: #333; color: white; } /* Fix for white-on-white in some browsers */
        [data-theme="light"] option { background-color: #fff; color: #333; }

        /* Project Buttons */
        .project-buttons { display: flex; gap: var(--spacing-lg); flex-wrap: wrap; }
        .btn-project {
            flex: 1;
            background: var(--bg);
            color: white;
            border: 1px solid var(--border);
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            min-width: 180px;
        }
        [data-theme="light"] .btn-project { color: #333; }

        .btn-project:hover { border-color: var(--text); transform: translateY(-1px); }
        .emoji-icon { font-size: 1.3rem; line-height: 1; }

        /* Mode Selector */
        .mode-selector { display: flex; gap: var(--spacing-xl); margin-bottom: 25px; }
        .mode-selector button {
            flex: 1;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
            font-weight: 700;
            cursor: pointer;
            font-family: inherit;
        }
        .mode-selector button.active {
            background-color: var(--accent);
            color: #1d2c5e; 
            border-color: var(--accent);
        }
        /* Retro theme fix for active button text */
        [data-theme="retro"] .mode-selector button.active {
            color: #fff;
        }

        /* --- UPLOAD AREA --- */
        .upload-area { display: grid; gap: 15px; margin-bottom: 25px; width: 100%; }
        .upload-area[data-mode="single"] { grid-template-columns: 200px; justify-content: center; }
        .upload-area[data-mode="quad"] { grid-template-columns: repeat(4, 1fr); }
        .upload-area[data-mode="unique"] { grid-template-columns: repeat(4, 1fr); }

        .file-input-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 26.6 / 20; 
            border: 2px dashed var(--border);
            border-radius: 8px;
            box-sizing: border-box;
            overflow: hidden;
            background: rgba(0,0,0,0.1);
        }
        .file-input-wrapper input[type=file] {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            opacity: 0; cursor: pointer; z-index: 20;
        }
        .btn-upload {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: none; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; background: transparent; color: var(--text);
            box-sizing: border-box; padding: 5px;
            z-index: 15; pointer-events: none;
        }
        .btn-upload .btn-mini-action, .btn-upload .refresh-icon-box { pointer-events: auto; }

        .refresh-icon-box {
            border: 1px solid var(--border); width: 30px; height: 30px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px; margin-bottom: 5px; font-size: 0.9rem;
        }
        .btn-upload span { font-size: 0.8rem; line-height: 1.1; font-weight: 500; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
        .btn-upload small { font-size: 0.6rem; opacity: 0.8; margin-top: 2px; display: block; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
        
        .btn-preview {
            width: 100%; height: 100%; object-fit: cover;
            border-radius: 6px; display: none;
            position: absolute; top:0; left:0; z-index: 10;
        }
        
        /* Delete Button in Square */
        .btn-delete {
            width: 24px; height: 24px; font-size: 14px;
            background: var(--red-btn); border: 1px solid white;
            color: white; border-radius: 50%;
            position: absolute; top: 5px; right: 5px; z-index: 30;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transition: transform 0.2s;
            pointer-events: auto;
        }
        .btn-delete:hover { transform: scale(1.1); filter: brightness(1.1); }

        /* Action Bar */
        .action-bar {
            display: flex; align-items: center; justify-content: space-between;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 203, 5, 0.3);
            flex-wrap: wrap; gap: 15px;
        }
        
        .help-btn {
            width: 32px; height: 32px;
            border: 2px solid var(--text); border-radius: 50%;
            background: transparent; color: var(--text);
            font-weight: bold; font-size: 1.2rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }

        .toggles { display: flex; gap: 20px; align-items: center; }
        .toggle-label { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 0.95rem; cursor: pointer; }
        .toggle-label input { width: 18px; height: 18px; accent-color: var(--text); cursor: pointer; }

        .actions-right { display: flex; gap: var(--spacing-lg); align-items: center; }

        /* Base button styles - consolidation */
        .btn-purple, .btn-green {
            color: white;
            border: none;
            padding: var(--btn-padding);
            border-radius: var(--radius-md);
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            font-family: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
        }

        .btn-purple { background-color: var(--purple-btn); }
        .btn-green { background-color: var(--green-btn); }

        .save-group {
            display: flex;
            border-radius: var(--radius-md);
            overflow: hidden;
            background: var(--bg);
            border: 1px solid var(--border);
            align-items: center;
        }
        .save-group select {
            background: var(--bg);
            border: none;
            border-radius: 0;
            padding: var(--spacing-sm);
            color: var(--text);
            width: auto;
            cursor: pointer;
        }
        .save-separator {
            width: 1px;
            height: 24px;
            background-color: var(--border);
            margin: 0 5px;
            opacity: 0.5;
        }

        /* --- STAMP & EDITOR --- */
        .stamp-selector {
            background: var(--light-blue);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .stamp-selector label { font-weight: 800; margin-bottom: var(--spacing-md); display: block; font-size: 1.1rem; }

        .stamp-list {
            display: flex;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
            margin-bottom: var(--spacing-lg);
            overflow-x: hidden;
        }
        .btn-stamp-add {
            font-size: 1.5rem;
            padding: var(--btn-padding-sm);
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: var(--radius-md);
            cursor: pointer;
            min-width: 45px;
            text-align: center;
        }

        /* Custom Stamp Input */
        .custom-stamp-input {
            padding: var(--btn-padding-sm);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
            text-align: center;
            font-weight: bold;
            width: 150px;
        }
        .custom-stamp-input::placeholder { color: var(--text); opacity: 0.7; font-weight: normal; }
        
        .text-stamp-controls {
            border-top: 1px solid var(--border); padding-top: 15px;
            display: flex; gap: 10px; flex-wrap: wrap; align-items: center;
        }
        .text-input {
            flex: 2; padding: 10px; border-radius: 6px;
            border: 1px solid var(--border); background-color: var(--bg);
            color: var(--text); font-weight: 700; font-family: inherit;
        }
        
        #paper {
            width: var(--paper-width); height: var(--paper-height);
            background-color: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            position: relative; display: flex; justify-content: center; align-items: center;
            overflow: hidden; flex-shrink: 0; color: black;
            transition: width 0.3s, height 0.3s;
            margin-bottom: 20px;
        }
        
        #background-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; background-size: cover; background-position: center; }
        #stamp-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }

        .stamp-wrapper { position: absolute; cursor: grab; user-select: none; display: inline-block; line-height: 1; pointer-events: auto; transform-origin: center center; touch-action: none; }
        .stamp-wrapper:active { cursor: grabbing; }
        .stamp-content { font-size: 3rem; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); white-space: nowrap; }
        .stamp-wrapper.selected { z-index: 100; }
        .stamp-wrapper.selected .stamp-content { outline: 2px dashed var(--accent); background-color: rgba(255, 255, 255, 0.2); border-radius: 4px; }
        .stamp-wrapper.grabbed .stamp-content { outline: 3px solid #ff3333; cursor: grabbing; }
        
        .stamp-controls { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .stamp-wrapper.selected .stamp-controls { display: block; }
        
        .handle {
            position: absolute; width: 24px; height: 24px;
            background: white; border: 2px solid #333; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; font-weight: 800; cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3); color: #333; z-index: 101;
        }
        .handle:hover { background-color: #f0f0f0; transform: scale(1.1); }
        .handle-del { top: -12px; left: -12px; color: #ff3333; border-color: #ff3333; }
        .handle-rot { top: -12px; right: -12px; cursor: alias; }
        .handle-sz  { bottom: -12px; right: -12px; cursor: nwse-resize; }

        #sticker-grid {
            display: grid;
            grid-template-columns: repeat(4, var(--cell-width));
            grid-template-rows: repeat(4, var(--cell-height));
            gap: var(--gap);
            width: var(--grid-width); height: var(--grid-height);
            z-index: 1; pointer-events: none; 
        }

        .cell {
            width: var(--cell-width); height: var(--cell-height);
            position: relative; overflow: hidden; background: #eee; pointer-events: auto; 
        }
        .img-container { width: 100%; height: 100%; position: relative; }
        .img-container > img.source-image { width: 100%; height: 100%; object-fit: cover; display: block; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; opacity: 0; transition: opacity 0.2s;
        }
        .overlay.visible { opacity: 1; }
        .overlay path { fill: none; stroke: white; stroke-width: 0.8px; vector-effect: non-scaling-stroke; filter: drop-shadow(0px 0px 1px rgba(0,0,0,0.3)); }

        .cell-effect-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; opacity: 0; transition: opacity 0.2s; }
        .crt-cell-overlay { background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%); background-size: 100% 2px; mix-blend-mode: multiply; }
        .cell.crt-active .crt-cell-overlay { opacity: 1; }

        .cell.weathered-active img { filter: sepia(0.2) saturate(0.8) contrast(1.1) brightness(0.95); }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 2500;
            display: none; justify-content: center; align-items: center; flex-direction: column; color: white;
        }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #007bff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Modals - FIXED: Start hidden */
        .modal-overlay {
            display: none; /* Hidden by default */
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: rgba(0,0,0,0.6); 
            z-index: 2000; 
            justify-content: center; 
            align-items: center;
        }
        .modal-content {
            background: var(--light-blue); color: var(--text); padding: 30px; border-radius: 12px;
            max-width: 550px; width: 90%; max-height: 80vh; overflow-y: auto;
            position: relative; box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 4px solid var(--border);
        }
        .modal-close { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text); padding: 0; width: auto; height: auto; }

        /* Toast Notification */
        .toast-notification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: #fff; padding: 12px 24px;
            border-radius: 8px; font-size: 14px; z-index: 3000;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .toast-notification.visible { opacity: 1; }

        /* Gamepad Focus */
        .gamepad-focus { box-shadow: 0 0 0 4px var(--accent), 0 0 15px var(--accent) !important; transform: scale(1.02); z-index: 50; }
        .gamepad-mode-indicator {
            position: fixed; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.8); color: #fff; padding: 10px 15px;
            border-radius: 20px; border: 2px solid var(--accent);
            font-size: 0.8rem; z-index: 9999;
            display: flex; align-items: center; gap: 10px;
            opacity: 0; transition: opacity 0.3s;
        }
        .gamepad-mode-indicator.visible { opacity: 1; }

        /* Responsive - Consolidated */
        @media (max-width: 768px) {
            .upload-area[data-mode="quad"], .upload-area[data-mode="unique"] { grid-template-columns: repeat(2, 1fr); }
            .action-bar { justify-content: center; gap: var(--spacing-xl); }
            .toggles { flex-wrap: wrap; justify-content: center; gap: var(--spacing-lg); }
            #paper { transform-origin: top center; transform: scale(0.8); margin-bottom: -20mm; }

            /* Touch targets - use CSS variables */
            .help-btn { width: var(--touch-target); height: var(--touch-target); font-size: 1.4rem; }
            .toggle-label input { width: 24px; height: 24px; }
            .btn-purple, .btn-green, .mode-selector button, .btn-project { min-height: var(--touch-target-lg); padding: var(--btn-padding-lg); }
            .btn-stamp-add { min-width: var(--touch-target-lg); min-height: var(--touch-target-lg); font-size: 1.6rem; }
            .custom-stamp-input { min-height: var(--touch-target-lg); width: 180px; font-size: 1rem; }
            .text-input, select { min-height: var(--touch-target-lg); font-size: 1rem; }

            /* Better spacing */
            .actions-right { gap: var(--spacing-md); flex-wrap: wrap; justify-content: center; }
            .stamp-list { gap: var(--spacing-md); }
            .text-stamp-controls { gap: var(--spacing-md); }
        }

        @media (max-width: 480px) {
            .upload-area[data-mode="quad"], .upload-area[data-mode="unique"] { grid-template-columns: 1fr; }
            #paper { transform: scale(0.55); margin-bottom: -45mm; }
            body { padding: var(--spacing-sm); }
            .control-section { padding: var(--spacing-lg); }

            /* Stack layouts */
            .actions-right { width: 100%; flex-direction: column; }
            .btn-purple { width: 100%; justify-content: center; }
            .save-group { width: 100%; }
            .save-group select { flex: 1; }
            .mode-selector { flex-direction: column; gap: var(--spacing-sm); }
            .mode-selector button { width: 100%; }
            .project-buttons { flex-direction: column; }
            .btn-project { width: 100%; min-width: auto; }
            .text-stamp-controls { flex-direction: column; }
            .text-stamp-controls > * { width: 100%; }
            .text-input { min-width: auto; }

            /* Modal optimization */
            .modal-content { width: 95%; padding: var(--spacing-xl); max-height: 85vh; }
            .modal-close { width: 36px; height: 36px; }
            .fullscreen-crop-close { width: var(--touch-target-lg); height: var(--touch-target-lg); font-size: 28px; }
            .fullscreen-crop-btn { min-height: var(--touch-target-xl); padding: 14px 20px; font-size: 1.1rem; }

            /* Very small screens */
            @media (max-width: 380px) {
                body { padding: 5px; }
                .control-section { padding: var(--spacing-sm); }
                #paper { transform: scale(0.45); margin-bottom: -55mm; }
                .btn-purple, .btn-green, .mode-selector button { font-size: 0.9rem; padding: var(--spacing-md) 16px; }
                .fullscreen-crop-btn { font-size: 0.95rem; padding: var(--spacing-md) 16px; }
            }
        }

        /* Landscape mode optimizations */
        @media (max-height: 600px) and (orientation: landscape) {
            #paper { transform: scale(0.6); margin-bottom: -30mm; }
            .control-section { padding: var(--spacing-sm); }
            .fullscreen-crop-modal .fullscreen-crop-body { padding: var(--spacing-sm); }
            .fullscreen-crop-controls { padding: var(--spacing-md); gap: var(--spacing-sm); }
        }

        /* iOS Safari specific fixes */
        @supports (-webkit-touch-callout: none) {
            input, select, textarea {
                font-size: 16px !important; /* Prevents iOS zoom on focus */
            }

            .custom-stamp-input,
            .text-input {
                font-size: 16px !important;
            }
        }

        /* Prevent double-tap zoom on buttons */
        button, .btn, .btn-purple, .btn-green, .btn-project {
            touch-action: manipulation;
        }

        /* Better safe area handling for notched devices */
        @supports (padding: env(safe-area-inset-top)) {
            body {
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
            }
        }
        
        .emoji-wallpaper { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; overflow: hidden; opacity: 0; transition: opacity 0.5s ease; }
        .emoji-wallpaper.active { opacity: 1; }
        .emoji-wallpaper span { position: absolute; font-size: 24px; animation: float 8s ease-in-out infinite; opacity: 0.6; }
        @keyframes float { 0%, 100% { transform: translateY(0) rotate(0deg); } 50% { transform: translateY(-15px) rotate(10deg); } }

        /* Print Styles */
        @media print {
            body {
                margin: 0;
                padding: 0;
                background: white !important;
            }
            .controls,
            .stamp-selector,
            .emoji-wallpaper,
            .gamepad-mode-indicator,
            .toast-notification,
            .modal-overlay,
            .fullscreen-crop-modal,
            .cell-controls,
            button[onclick="downloadCuttingTemplate()"] {
                display: none !important;
            }
            #paper {
                margin: 0 auto;
                box-shadow: none;
                transform: none !important;
                page-break-after: avoid;
            }
            .stamp-wrapper.selected .stamp-content {
                outline: none !important;
                background: none !important;
            }
            .stamp-controls {
                display: none !important;
            }
            @page {
                margin: 0;
            }
        }

        /* Cell Controls for Touch */
        .cell-controls {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 4px;
            z-index: 25;
            padding: 4px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 6px;
            backdrop-filter: blur(4px);
        }
        .cell.selected .cell-controls { display: flex; }

        .cell-control-btn {
            width: 28px;
            height: 28px;
            border: 1px solid white;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            user-select: none;
        }
        .cell-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .cell-control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        /* Touch feedback */
        @media (hover: none) {
            .cell-control-btn:active {
                background: var(--accent);
                border-color: var(--accent);
                animation: tapPulse 0.3s ease;
            }
        }
        @keyframes tapPulse {
            0% { transform: scale(1); }
            50% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        /* Cell tap indicator */
        .cell {
            position: relative;
            transition: transform 0.1s ease;
        }
        .cell:active {
            transform: scale(0.98);
        }

        /* Stamp touch feedback */
        .stamp-wrapper {
            transition: transform 0.1s ease;
        }
        .stamp-wrapper:active {
            transform: translate(-50%, -50%) scale(1.05) !important;
        }

        /* Touch hint for empty cells */
        .cell:not(.has-image)::after {
            content: 'Tap to upload';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        @media (hover: none) and (max-width: 768px) {
            .cell:not(.has-image)::after {
                opacity: 1;
            }
        }

        /* Larger touch targets on mobile */
        @media (max-width: 768px) {
            .handle {
                width: 44px !important;
                height: 44px !important;
                font-size: 18px;
            }
            .cell-control-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            .cell-controls {
                bottom: 4px;
                padding: 6px;
                gap: 6px;
            }
            /* Show controls on touch devices when cell is selected */
            .cell.selected .cell-controls {
                display: flex !important;
            }
        }

        /* Fullscreen Cropper Modal */
        .fullscreen-crop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            flex-direction: column;
        }
        .fullscreen-crop-modal.active { display: flex; }

        .fullscreen-crop-header {
            padding: 15px 20px;
            background: var(--light-blue);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid var(--border);
            flex-shrink: 0;
        }
        .fullscreen-crop-header h3 {
            margin: 0;
            font-size: 1.2rem;
        }
        .fullscreen-crop-close {
            background: var(--red-btn);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-crop-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }
        .fullscreen-crop-container {
            max-width: 90vw;
            max-height: 60vh;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .fullscreen-crop-container img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .fullscreen-crop-controls {
            padding: 20px;
            background: var(--light-blue);
            border-top: 2px solid var(--border);
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .fullscreen-crop-btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 700;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 48px;
            transition: all 0.2s;
        }
        .fullscreen-crop-btn:active {
            transform: scale(0.95);
            background: var(--accent);
            color: var(--bg);
        }
        .zoom-display {
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-weight: 700;
            font-size: 1.1rem;
            min-width: 80px;
            text-align: center;
        }
    </style>
</head>
<body data-theme="video-rental">

<div class="emoji-wallpaper" id="emojiWallpaper"></div>
<div id="gp-indicator" class="gamepad-mode-indicator"><span class="icon">üéÆ</span><span id="gp-mode-text">Menu Mode</span></div>
<div id="toast" class="toast-notification">Notification Message</div>
<div id="loading-overlay"><div class="spinner"></div><p>Processing...</p></div>

<!-- HELP MODAL -->
<div id="help-modal" class="modal-overlay" onclick="toggleHelp()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <button class="modal-close" onclick="toggleHelp()">√ó</button>
        <h2 style="margin-top:0;">User Guide</h2>
        <div class="guide-section">
            <h3>Layouts</h3>
            <ul>
                <li><strong>1 Photo (1x16):</strong> Repeats 1 image 16 times.</li>
                <li><strong>4 Photos (2x2 Grid):</strong> Fills 4 quadrants.</li>
                <li><strong>16 Unique Photos:</strong> Individual control for every sticker.</li>
            </ul>
        </div>
        <div class="guide-section">
            <h3>Editing</h3>
            <p><strong>Double-click</strong> any sticker to reset its zoom and position.</p>
            <p><strong>Tap the üîç button</strong> to open fullscreen editing mode (great for mobile!).</p>
        </div>
        <div class="guide-section">
            <h3>Cutting Template</h3>
            <p>The "Download Cutting Template (SVG)" button generates a vector file compatible with cutting plotters such as the <strong>Cricut¬Æ</strong> or <strong>Silhouette‚Ñ¢</strong>. This file contains the cut lines for the stickers.</p>
        </div>
        <div class="guide-section">
            <h3>Paste Images</h3>
            <p>Press <strong>Ctrl+V</strong> (or <strong>Cmd+V</strong>) anywhere to paste images from your clipboard.</p>
        </div>
    </div>
</div>

<!-- FULLSCREEN CROP MODAL -->
<div id="fullscreen-crop-modal" class="fullscreen-crop-modal">
    <div class="fullscreen-crop-header">
        <h3>‚úÇÔ∏è Crop Sticker</h3>
        <button class="fullscreen-crop-close" onclick="closeFullscreenCrop()">√ó</button>
    </div>
    <div class="fullscreen-crop-body">
        <div class="fullscreen-crop-container" id="fullscreen-crop-container">
            <img id="fullscreen-crop-image" src="" alt="Crop">
        </div>
    </div>
    <div class="fullscreen-crop-controls">
        <button class="fullscreen-crop-btn" onclick="zoomFullscreenCrop(-0.1)">
            <span style="font-size:1.5rem;">‚àí</span> Zoom Out
        </button>
        <div class="zoom-display" id="fullscreen-zoom-display">100%</div>
        <button class="fullscreen-crop-btn" onclick="zoomFullscreenCrop(0.1)">
            <span style="font-size:1.5rem;">+</span> Zoom In
        </button>
        <button class="fullscreen-crop-btn" onclick="resetFullscreenCrop()">
            ‚Üª Reset
        </button>
        <button class="fullscreen-crop-btn" style="background: var(--green-btn); border-color: var(--green-btn);" onclick="closeFullscreenCrop()">
            ‚úì Done
        </button>
    </div>
</div>

<div class="controls">
    
    <!-- 1. Top Settings -->
    <div class="control-section">
        <div class="settings-row">
            <div class="setting-group">
                <label>Theme:</label>
                <select id="theme-select" onchange="changeTheme(this.value)">
                    <optgroup label="Color Themes">
                        <option value="video-rental" selected>Video Rental</option>
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                        <option value="retro">Retro</option>
                        <option value="1-up" hidden disabled id="theme-1up-option">üçÑ 1-UP</option>
                    </optgroup>
                    <optgroup label="Wallpaper Themes">
                        <option value="hearts">Hearts & Bubbles üíñ</option>
                        <option value="vines">Vines & Flowers üåø</option>
                    </optgroup>
                </select>
            </div>
            <div class="setting-group">
                <label>Background Pattern:</label>
                 <select id="bg-select" onchange="changeBackground(this.value)">
                    <option value="none">None (White)</option>
                    <option value="hearts">Hearts</option>
                    <option value="stripes">Stripes</option>
                    <option value="flowers">Flowers</option>
                    <option value="custom">Custom...</option>
                </select>
                <input type="file" id="custom-bg-input" accept="image/*" style="display:none" onchange="handleCustomBackground(event)">
            </div>
            <div class="setting-group">
                <label>Paper Size:</label>
                <select id="paper-size" onchange="changePaperSize(this.value)">
                    <option value="4x6">4" x 6" (Recommended)</option>
                    <option value="hagaki">100mm x 148mm (Official)</option>
                    <option value="letter">8.5" x 11" (Letter)</option>
                </select>
            </div>
        </div>
    </div>
    
    <!-- 2. Project Buttons -->
    <div class="control-section">
        <div class="project-buttons">
            <button class="btn-project" onclick="saveProject()">
                <span class="emoji-icon">üíæ</span> Save Project
            </button>
            <button class="btn-project" onclick="document.getElementById('load-project-input').click()">
                <span class="emoji-icon">üìÇ</span> Load Project
            </button>
            <input type="file" id="load-project-input" accept=".json" style="display:none" onchange="loadProject(event)">
        </div>
    </div>
    
    <!-- 3. Layout, Upload, Actions -->
    <div class="control-section">
        <div class="mode-selector">
            <button onclick="setMode('single')" id="btn-single">1 Photo (1x16)</button>
            <button onclick="setMode('quad')" id="btn-quad">4 Photos (2x2 Grid)</button>
            <button onclick="setMode('unique')" id="btn-unique">16 Unique Photos</button>
        </div>
        
        <!-- The Upload Grid -->
        <div class="upload-area" id="upload-inputs" data-mode="quad"></div>

        <div class="action-bar">
            <!-- Left -->
            <button class="help-btn" onclick="toggleHelp()" title="Open Guide">?</button>
            
            <!-- Center Toggles -->
            <div class="toggles">
                <label class="toggle-label">
                    <input type="checkbox" id="toggle-overlay" onchange="toggleOverlay()">
                    Show Kiss Cut
                </label>

                <label class="toggle-label" title="Simulates faded, old ink">
                    <input type="checkbox" id="toggle-weathered" onchange="toggleWeathered()">
                    Fade
                </label>
                
                <label class="toggle-label" title="Simulates CRT scanlines">
                    <input type="checkbox" id="toggle-crt" onchange="toggleCRT()">
                    CRT Effect
                </label>
            </div>
            
            <!-- Right Actions -->
            <div class="actions-right">
                <input type="file" id="bulk-input" multiple accept="image/png, image/jpeg, image/gif, image/webp, video/webm" style="display:none" onchange="handleBulkUpload(event)">
                
                <button class="btn-purple" onclick="importFromSnapStation()">
                    <span class="emoji-icon">üì∑</span> Import Snaps
                </button>

                <button class="btn-purple" onclick="document.getElementById('bulk-input').click()">
                    <span class="emoji-icon">üì§</span> Upload
                </button>

                <button class="btn-purple" onclick="printStickers()" title="Print the sticker sheet directly">
                    <span class="emoji-icon">üñ®Ô∏è</span> Print
                </button>

                <div class="save-group">
                    <select id="export-format">
                        <option value="png">PNG</option>
                        <option value="jpg">JPG</option>
                        <option value="pdf">PDF</option>
                        <option value="gif">GIF</option>
                    </select>
                    <div class="save-separator"></div>
                    <button class="btn-green" onclick="saveOutput()">Save</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="paper">
    <div id="background-layer"></div>
    <div id="sticker-grid"></div>
    <div id="dither-overlay"></div>
    <div id="crt-overlay"></div>
    <div id="stamp-layer"></div>
</div>

<button class="btn-project" onclick="downloadCuttingTemplate()" style="display:block; width:100%; max-width:800px; margin:20px auto; justify-content:center; background: var(--light-blue); color: var(--text);">
    Download Cutting Template (SVG)
</button>

<div class="stamp-selector">
    <label>Add Stamp:</label>
    <div class="stamp-list" id="stamp-list-container">
        <!-- Stamps generated dynamically via JavaScript -->
        <input type="text" placeholder="Type or paste emoji" class="custom-stamp-input" id="custom-emoji-input" onkeypress="if(event.key === 'Enter'){ window.addStamp(this.value); this.value=''; }">
        <button class="btn-stamp-add" onclick="addCustomEmoji()" title="Add custom emoji" style="background: var(--accent); color: var(--bg); font-weight: bold;">+</button>
    </div>
    
    <div class="text-stamp-controls">
        <input type="text" id="text-stamp-input" placeholder="Type text..." class="text-input">
        <select id="text-font-select" style="flex:1;">
            <option value="'Press Start 2P', cursive">8-Bit</option>
            <option value="'Bangers', cursive">Comic</option>
            <option value="'Permanent Marker', cursive">Marker</option>
            <option value="'VT323', monospace">Terminal</option>
            <option value="'Pacifico', cursive">Script</option>
        </select>
        <input type="color" id="text-color-input" value="#000000" class="color-input">
        <button class="btn-green" style="border-radius:6px; color:white;" onclick="addTextStampFromInput()">Add</button>
    </div>
</div>

<script>
    (function() {
        // Global variables
        window.groupImages = [];
        window.cropperInstances = [];
        window.cellGroups = new Array(16).fill(0);
        let activeStamp = null;

        // State
        window.currentMode = 'quad'; 
        let isSyncing = false; 
        let syncFrameId = null;
        let interactionMode = null;
        let startX, startY, startLeft, startTop, startRotation, startFontSize, centerX, centerY, dragSrcIndex = null;

        // DOM Elements
        const gridEl = document.getElementById('sticker-grid');
        const uploadContainer = document.getElementById('upload-inputs');
        const bgLayer = document.getElementById('background-layer');
        const stampLayer = document.getElementById('stamp-layer');
        const paperElement = document.getElementById('paper');
        
        // Cache cell selector
        const allCells = () => document.querySelectorAll('.cell');

        const bgPatterns = {
            hearts: `data:image/svg+xml;charset=utf-8,<svg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23FFB6C1'/><text x='0' y='15' font-size='15'>‚ù§Ô∏è</text><text x='20' y='35' font-size='15'>‚ù§Ô∏è</text><text x='20' y='15' font-size='15'>ü´ß</text><text x='0' y='35' font-size='15'>ü´ß</text></svg>`,
            stripes: `data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='40' height='40' fill='%23FFCB05'/%3E%3Cpath d='M0 40 L40 0 L20 0 L0 20 Z M40 40 L40 20 L20 40 Z' fill='black'/%3E%3C/svg%3E`,
            flowers: `data:image/svg+xml;charset=utf-8,<svg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23C1FFB6'/><text x='0' y='15' font-size='15'>üåø</text><text x='20' y='35' font-size='15'>üåø</text><text x='20' y='15' font-size='15'>üå∏</text><text x='0' y='35' font-size='15'>üå∏</text></svg>`
        };

        const stickerW = 26.6, stickerH = 20;
        const innerX = 1.25, innerY = 0.833;
        const innerW = 24.1, innerH = 17.5;
        const radius = 2.75;
        
        const overlayPath = `M ${innerX+radius} ${innerY} L ${innerX+innerW-radius} ${innerY} Q ${innerX+innerW} ${innerY} ${innerX+innerW} ${innerY+radius} L ${innerX+innerW} ${innerY+innerH-radius} Q ${innerX+innerW} ${innerY+innerH} ${innerX+innerW-radius} ${innerY+innerH} L ${innerX+radius} ${innerY+innerH} Q ${innerX} ${innerY+innerH} ${innerX} ${innerY+innerH-radius} L ${innerX} ${innerY+radius} Q ${innerX} ${innerY} ${innerX+radius} ${innerY} Z`;

        function init() {
            gridEl.innerHTML = '';
            window.cropperInstances = new Array(16).fill(null);

            for(let i=0; i<16; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${i}`;

                // Click to Select Cell (shows zoom controls)
                cell.addEventListener('click', function(e) {
                    // Don't select if clicking on control buttons
                    if (e.target.classList.contains('cell-control-btn')) return;

                    // Deselect all cells
                    document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
                    // Select this cell
                    this.classList.add('selected');
                });

                // Double Click Reset
                cell.addEventListener('dblclick', function() {
                    const idx = parseInt(this.id.split('-')[1]);
                    if (window.cropperInstances[idx]) {
                        window.cropperInstances[idx].reset();
                    }
                });

                const imgContainer = document.createElement('div');
                imgContainer.className = 'img-container';
                const img = document.createElement('img');
                img.className = 'source-image';
                img.style.display = 'none';
                imgContainer.appendChild(img);
                cell.appendChild(imgContainer);

                const crtOverlay = document.createElement('div');
                crtOverlay.className = 'cell-effect-layer crt-cell-overlay';
                cell.appendChild(crtOverlay);

                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                overlay.innerHTML = `<svg viewBox="0 0 26.6 20"><path d="${overlayPath}" /></svg>`;
                cell.appendChild(overlay);

                // Cell Controls for Touch
                const controls = document.createElement('div');
                controls.className = 'cell-controls';
                controls.innerHTML = `
                    <button class="cell-control-btn" onclick="zoomCell(${i}, -0.1)" title="Zoom Out">‚àí</button>
                    <button class="cell-control-btn" onclick="zoomCell(${i}, 0.1)" title="Zoom In">+</button>
                    <button class="cell-control-btn" onclick="openFullscreenCrop(${i})" title="Edit Fullscreen">üîç</button>
                `;
                cell.appendChild(controls);

                gridEl.appendChild(cell);
            }

            window.setMode('quad');

            window.addEventListener('mousedown', handleGlobalMouseDown);
            window.addEventListener('mousemove', handleGlobalMouseMove);
            window.addEventListener('mouseup', handleGlobalMouseUp);
            window.addEventListener('touchstart', handleGlobalMouseDown);
            window.addEventListener('touchmove', handleGlobalMouseMove, {passive: false});
            window.addEventListener('touchend', handleGlobalMouseUp);

            // Initialize stamps with event delegation
            initStamps();
        }

        // Stamp list - dynamically generated
        function initStamps() {
            const stamps = ['‚ö°','üî•','üíß','üå±','‚ùÑÔ∏è','ü™®','üêâ','üß™','üåÄ','üå©Ô∏è','üéÆ','‚≠ê','üéí','üß¢','üîé','üèãÔ∏è','‚öîÔ∏è','üìç','üì∏','ü§≥','üéûÔ∏è','üì∑','üñºÔ∏è','üåø','üåã','üèúÔ∏è','üåä','üåå','ü™µ','‚ú®','üíê','üçé','üîî','üí´','üò≤','üí§','‚≠ê','üìù','‚ûï','üéØ','üëÄ','üöô','üõ§Ô∏è','üõ∞Ô∏è','üì°','üîç','ü™à','üé∂','üéµ','üíú','üíô','üíö','üíõ','ü§ç','ü§é','ü©∑','ü©µ','ü©∂','üò≤','ü•∫','üò≥','ü•∞','üòª','ü§ó','üòá','üå∏','üêæ','üéÄ','üê±','üß∏','üëª','‚ò†Ô∏è','üíÄ'];

            const container = document.getElementById('stamp-list-container');
            const customInput = container.querySelector('.custom-stamp-input');

            // Generate stamp buttons
            const buttonsHTML = stamps.map(stamp =>
                `<button class="btn-stamp-add" data-stamp="${stamp}">${stamp}</button>`
            ).join('');

            // Insert before custom input
            customInput.insertAdjacentHTML('beforebegin', buttonsHTML);

            // Event delegation for stamp buttons
            container.addEventListener('click', (e) => {
                if (e.target.classList.contains('btn-stamp-add') && e.target.dataset.stamp) {
                    window.addStamp(e.target.dataset.stamp);
                }
            });
        }

        // --- KONAMI CODE ---
        const konamiSeq = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a', 'Enter'];
        let konamiIndex = 0;

        document.addEventListener('keydown', (e) => {
            if (e.key === konamiSeq[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiSeq.length) {
                    unlock1UpTheme();
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });

        window.unlock1UpTheme = function() {
            const opt = document.getElementById('theme-1up-option');
            if(opt) {
                opt.removeAttribute('hidden');
                opt.removeAttribute('disabled');
                const select = document.getElementById('theme-select');
                select.value = '1-up';
                changeTheme('1-up');
                showToast('üçÑ 1-UP Theme Unlocked!');
            }
        }

        // --- THEME & WALLPAPER LOGIC ---
        const emojiConfigs = {
            hearts: ['üíñ', 'ü´ß', 'üíò', 'üßº'],
            vines: ['üåø', 'üå∏', 'üçÉ', 'üåª'],
            '1-up': ['üçÑ', '‚≠ê', 'ü™ô', 'üê¢', '‚ùì']
        };

        const emojiWallpaper = document.getElementById('emojiWallpaper');

        function generateEmojiWallpaper(theme) {
            emojiWallpaper.innerHTML = '';
            if (!emojiConfigs[theme]) {
                emojiWallpaper.classList.remove('active');
                return;
            }

            const emojis = emojiConfigs[theme];
            for (let i = 0; i < 80; i++) {
                const span = document.createElement('span');
                span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                span.style.left = `${Math.random() * 100}%`;
                span.style.top = `${Math.random() * 100}%`;
                span.style.animationDelay = `${Math.random() * 8}s`;
                span.style.fontSize = `${Math.random() * 20 + 16}px`;
                emojiWallpaper.appendChild(span);
            }
            emojiWallpaper.classList.add('active');
        }

        window.changeTheme = function(themeValue) {
            document.body.setAttribute('data-theme', themeValue);
            generateEmojiWallpaper(themeValue);
        }

        // --- VECTOR SVG EXPORT ---
        window.downloadCuttingTemplate = function() {
            const paperSelect = document.getElementById('paper-size').value;
            let pW_mm = 152.4, pH_mm = 101.6, scalingFactor = 1.0;

            if (paperSelect === 'hagaki') {
                pW_mm = 148; pH_mm = 100;
            } else if (paperSelect === 'letter') {
                pW_mm = 279.4; pH_mm = 215.9; scalingFactor = 2.2;
            }

            const cellW = 26.6, cellH = 20, gap = 1;
            const effectiveCellW = cellW * scalingFactor;
            const effectiveCellH = cellH * scalingFactor;
            const effectiveGap = gap * scalingFactor;

            const gridTotalW = (effectiveCellW * 4) + (effectiveGap * 3);
            const gridTotalH = (effectiveCellH * 4) + (effectiveGap * 3);

            const marginLeft = (pW_mm - gridTotalW) / 2;
            const marginTop = (pH_mm - gridTotalH) / 2;

            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${pW_mm}mm" height="${pH_mm}mm" viewBox="0 0 ${pW_mm} ${pH_mm}">`;
            svgContent += `<rect x="0" y="0" width="${pW_mm}" height="${pH_mm}" fill="none" stroke="red" stroke-width="0.1" />`;
            
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    const x = marginLeft + (c * (effectiveCellW + effectiveGap));
                    const y = marginTop + (r * (effectiveCellH + effectiveGap));
                    svgContent += `<g transform="translate(${x}, ${y}) scale(${scalingFactor})">`;
                    svgContent += `<path d="${overlayPath}" fill="none" stroke="black" stroke-width="${0.1/scalingFactor}" />`;
                    svgContent += `</g>`;
                }
            }
            svgContent += `</svg>`;

            const blob = new Blob([svgContent], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'cutting-template.svg';
            link.click();
            URL.revokeObjectURL(url);
        }

        // --- PASTE FUNCTION ---
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => { toast.classList.remove('visible'); }, 4000);
        }

        // Global Paste Listener
        window.addEventListener('paste', function(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            const imageBlobs = [];
            
            for (let index in items) {
                const item = items[index];
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const blob = item.getAsFile();
                    imageBlobs.push(blob);
                }
            }

            if (imageBlobs.length > 0) {
                e.preventDefault(); 
                processPastedImages(imageBlobs);
                showToast(`Pasted ${imageBlobs.length} image(s)`);
            }
        });

        function processPastedImages(imageBlobs) {
            if (imageBlobs.length === 0) return;
            let targetMode;
            if (imageBlobs.length === 1) targetMode = 'single';
            else if (imageBlobs.length <= 4) targetMode = 'quad';
            else targetMode = 'unique';
            
            window.setMode(targetMode);
            setTimeout(() => {
                const numSlots = window.groupImages.length;
                imageBlobs.slice(0, numSlots).forEach((blob, index) => {
                    if (window.groupImages[index] && window.groupImages[index].url) {
                        URL.revokeObjectURL(window.groupImages[index].url);
                    }
                    window.groupImages[index] = { 
                        url: URL.createObjectURL(blob), 
                        canvasData: null, 
                        cropBoxData: null 
                    };
                });
                refreshGrid();
            }, 100);
        }

        // --- IMPORT FROM SNAP STATION ---
        window.importFromSnapStation = function() {
            try {
                const data = localStorage.getItem('snapstation-export');
                if (!data) {
                    showToast('No snaps queued. Select snaps in Snap Station and click "Send to Stickers".');
                    return;
                }
                
                let parsed;
                try { parsed = JSON.parse(data); } catch (e) {
                    showToast('Invalid data. Try again.');
                    localStorage.removeItem('snapstation-export');
                    return;
                }
                
                const images = parsed.images;
                
                if (!images || images.length === 0) {
                    showToast('No images found.');
                    localStorage.removeItem('snapstation-export');
                    return;
                }
                
                // Set appropriate mode
                if (images.length === 1) window.setMode('single');
                else if (images.length <= 4) window.setMode('quad');
                else window.setMode('unique');
                
                // Wait for mode switch to complete, then load images
                setTimeout(() => {
                    const numSlots = window.groupImages.length;
                    images.slice(0, numSlots).forEach((dataUrl, index) => {
                        // Clean up old URL if it's a blob URL
                        if (window.groupImages[index] && window.groupImages[index].url && window.groupImages[index].url.startsWith('blob:')) {
                            URL.revokeObjectURL(window.groupImages[index].url);
                        }
                        // Data URLs work directly - no need to convert
                        window.groupImages[index] = { 
                            url: dataUrl,  
                            canvasData: null, 
                            cropBoxData: null 
                        };
                    });
                    refreshGrid();
                    
                    const imported = Math.min(images.length, numSlots);
                    showToast(`Imported ${imported} snap${imported !== 1 ? 's' : ''}`);
                    
                    // Clear the export data after successful import
                    localStorage.removeItem('snapstation-export');
                }, 150);
            } catch(e) {
                console.error("Import failed:", e);
                showToast("Failed to import snaps.");
            }
        }

        // Auto-check for pending imports
        function checkForPendingImports() {
            try {
                const data = localStorage.getItem('snapstation-export');
                if (data) {
                    try {
                        const parsed = JSON.parse(data);
                        const count = parsed.images?.length || 0;
                        if (count > 0) {
                            showToast(`${count} snap${count !== 1 ? 's' : ''} ready to import. Click "Import Snaps".`);
                            return true;
                        }
                    } catch (e) {}
                }
            } catch(e) {}
            return false;
        }

        // Check on load
        setTimeout(checkForPendingImports, 500);

        // Listen for storage changes from other tabs/frames
        window.addEventListener('storage', (e) => {
            if (e.key === 'snapstation-export' && e.newValue) {
                checkForPendingImports();
            }
        });

        // Poll periodically (storage event doesn't fire in same window/frame)
        setInterval(() => {
            const data = localStorage.getItem('snapstation-export');
            if (data) checkForPendingImports();
        }, 2000);

        window.toggleHelp = function() {
            const modal = document.getElementById('help-modal');
            modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
        }

        window.changePaperSize = function(size) {
            const root = document.documentElement;
            if(size === '4x6') {
                root.style.setProperty('--paper-width', '152.4mm'); root.style.setProperty('--paper-height', '101.6mm');
                root.style.setProperty('--cell-width', '26.6mm'); root.style.setProperty('--cell-height', '20mm');
                root.style.setProperty('--gap', '1mm');
            } else if(size === 'hagaki') {
                root.style.setProperty('--paper-width', '148mm'); root.style.setProperty('--paper-height', '100mm');
                root.style.setProperty('--cell-width', '26.6mm'); root.style.setProperty('--cell-height', '20mm');
                root.style.setProperty('--gap', '1mm');
            } else {
                 root.style.setProperty('--paper-width', '279.4mm'); root.style.setProperty('--paper-height', '215.9mm');
                 root.style.setProperty('--cell-width', '58.52mm'); root.style.setProperty('--cell-height', '44mm');
                 root.style.setProperty('--gap', '2.2mm');
            }
        }

        window.toggleWeathered = function() {
            const show = document.getElementById('toggle-weathered').checked;
            allCells().forEach(cell => cell.classList.toggle('weathered-active', show));
        }

        window.toggleCRT = function() {
            const show = document.getElementById('toggle-crt').checked;
            allCells().forEach(cell => cell.classList.toggle('crt-active', show));
        }
        
        window.clearImage = function(index) {
            if (window.groupImages[index] && window.groupImages[index].url) {
                // Only revoke blob URLs, not data URLs
                if (window.groupImages[index].url.startsWith('blob:')) {
                    URL.revokeObjectURL(window.groupImages[index].url);
                }
            }
            window.groupImages[index] = null;
            const input = document.querySelector(`.file-input-wrapper[data-index="${index}"] input[type=file]`);
            if(input) input.value = '';
            refreshGrid();
        }

        // --- Custom Background Handling (Fixed Memory Leak) ---
        window.handleCustomBackground = function(event) {
            const bgLayer = document.getElementById('background-layer');
            const file = event.target.files[0]; if(!file) return;
            // Revoke old URL if stored
            if (bgLayer.dataset.customBgUrl) {
                URL.revokeObjectURL(bgLayer.dataset.customBgUrl);
            }
            const url = URL.createObjectURL(file);
            bgLayer.dataset.customBgUrl = url;
            bgLayer.style.backgroundImage = `url("${url}")`;
        }

        // --- Stamp Logic ---
        window.addStamp = function(emoji, x, y, size, rotation) {
            createStamp(emoji, x, y, size, rotation, false);
        }

        window.addTextStampFromInput = function() {
            const text = document.getElementById('text-stamp-input').value;
            if(!text) return;
            const font = document.getElementById('text-font-select').value;
            const color = document.getElementById('text-color-input').value;
            createStamp(text, undefined, undefined, undefined, undefined, true, font, color);
            document.getElementById('text-stamp-input').value = '';
        }

        window.addCustomEmoji = function() {
            const input = document.getElementById('custom-emoji-input');
            const emoji = input.value.trim();
            if(!emoji) {
                showToast('Please enter an emoji or text first');
                return;
            }
            window.addStamp(emoji);
            input.value = '';
        }

        function createStamp(contentStr, x, y, size, rotation, isText=false, font='', color='') {
            const wrapper = document.createElement('div');
            wrapper.className = 'stamp-wrapper';
            wrapper.dataset.isText = isText;
            if(isText) { wrapper.dataset.font = font; wrapper.dataset.color = color; }
            
            const paper = document.getElementById('paper');
            const initialX = x !== undefined ? x : (paper.offsetWidth / 2);
            const initialY = y !== undefined ? y : (paper.offsetHeight / 2);
            const initialSize = size !== undefined ? size : (isText ? '2rem' : '3rem');
            const initialRot = rotation !== undefined ? rotation : 0;

            wrapper.style.left = initialX + 'px';
            wrapper.style.top = initialY + 'px';
            wrapper.style.transform = `translate(-50%, -50%) rotate(${initialRot}deg)`;

            const content = document.createElement('div');
            content.className = 'stamp-content';
            content.innerText = contentStr;
            content.style.fontSize = initialSize;
            
            if(isText) {
                content.style.fontFamily = font;
                content.style.color = color;
                content.style.whiteSpace = 'nowrap';
                content.style.textShadow = '2px 2px 0px rgba(0,0,0,0.5)';
            }
            wrapper.appendChild(content);

            const controls = document.createElement('div');
            controls.className = 'stamp-controls';
            
            const createHandle = (cls, html, title) => {
                const el = document.createElement('div'); el.className = `handle ${cls}`; el.innerHTML = html; el.title = title;
                return el;
            };
            controls.appendChild(createHandle('handle-del', '√ó', 'Delete'));
            controls.appendChild(createHandle('handle-rot', '‚Üª', 'Rotate'));
            controls.appendChild(createHandle('handle-sz', '‚Üî', 'Resize'));

            wrapper.appendChild(controls);
            stampLayer.appendChild(wrapper);

            const handleStart = (e, mode) => { e.stopPropagation(); selectStamp(wrapper); startInteraction(e, wrapper, mode); };

            wrapper.addEventListener('mousedown', (e) => {
                e.stopPropagation(); selectStamp(wrapper);
                if (e.target.classList.contains('handle-del')) { wrapper.remove(); activeStamp = null; }
                else if (e.target.classList.contains('handle-rot')) { startInteraction(e, wrapper, 'rotate'); }
                else if (e.target.classList.contains('handle-sz')) { startInteraction(e, wrapper, 'resize'); }
                else { startInteraction(e, wrapper, 'drag'); }
            });
            
            wrapper.addEventListener('touchstart', (e) => {
                e.stopPropagation(); selectStamp(wrapper);
                const touch = e.touches[0];
                const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY, preventDefault: ()=>e.preventDefault() };
                if (e.target.classList.contains('handle-del')) { wrapper.remove(); activeStamp = null; }
                else if (e.target.classList.contains('handle-rot')) { startInteraction(fakeEvent, wrapper, 'rotate'); }
                else if (e.target.classList.contains('handle-sz')) { startInteraction(fakeEvent, wrapper, 'resize'); }
                else { startInteraction(fakeEvent, wrapper, 'drag'); }
            }, {passive: false});
        }

        function selectStamp(stamp) {
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected'));
            stamp.classList.add('selected'); activeStamp = stamp;
        }

        function deselectAll() {
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected'));
            activeStamp = null;
        }

        function startInteraction(e, wrapper, mode) {
            e.preventDefault();
            interactionMode = mode;
            startX = e.clientX; startY = e.clientY;
            startLeft = parseFloat(wrapper.style.left); startTop = parseFloat(wrapper.style.top);
            
            const st = window.getComputedStyle(wrapper);
            const tr = st.getPropertyValue("transform");
            let angle = 0;
            if (tr && tr !== 'none') {
                const values = tr.split('(')[1].split(')')[0].split(',');
                angle = Math.round(Math.atan2(values[1], values[0]) * (180/Math.PI));
            }
            startRotation = angle;
            const rect = wrapper.getBoundingClientRect();
            centerX = rect.left + rect.width / 2; centerY = rect.top + rect.height / 2;
            startFontSize = parseFloat(window.getComputedStyle(wrapper.querySelector('.stamp-content')).fontSize);
        }

        function handleGlobalMouseDown(e) {
            if (e.target.id === 'stamp-layer' || e.target.id === 'background-layer') {
                deselectAll();
                // Also deselect all cells when clicking on stamps or background
                document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
            }
            // Deselect cells when clicking outside of grid
            if (!e.target.closest('.cell') && !e.target.closest('.fullscreen-crop-modal')) {
                document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
            }
        }

        function handleGlobalMouseMove(e) {
            if (!activeStamp || !interactionMode) return;
            e.preventDefault();
            const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

            if (interactionMode === 'drag') {
                const dx = clientX - startX; const dy = clientY - startY;
                activeStamp.style.left = (startLeft + dx) + 'px';
                activeStamp.style.top = (startTop + dy) + 'px';
            } else if (interactionMode === 'resize') {
                const distStart = Math.hypot(startX - centerX, startY - centerY);
                const distNow = Math.hypot(clientX - centerX, clientY - centerY);
                const scale = distNow / distStart;
                const newSize = Math.max(10, startFontSize * scale); 
                activeStamp.querySelector('.stamp-content').style.fontSize = newSize + 'px';
            } else if (interactionMode === 'rotate') {
                const angleStart = Math.atan2(startY - centerY, startX - centerX);
                const angleNow = Math.atan2(clientY - centerY, clientX - centerX);
                const angleChange = (angleNow - angleStart) * (180 / Math.PI);
                activeStamp.style.transform = `translate(-50%, -50%) rotate(${startRotation + angleChange}deg)`;
            }
        }

        function handleGlobalMouseUp() { interactionMode = null; }

        function refreshGrid() {
            window.cellGroups.fill(-1);
            if (window.currentMode === 'single') { window.cellGroups.fill(0); } 
            else if (window.currentMode === 'unique') { for(let i=0; i<16; i++) window.cellGroups[i] = i; } 
            else if (window.currentMode === 'quad') {
                const mapping = [[0, 1, 4, 5], [2, 3, 6, 7], [8, 9, 12, 13], [10, 11, 14, 15]];
                mapping.forEach((indices, groupIdx) => { indices.forEach(cellIdx => window.cellGroups[cellIdx] = groupIdx); });
            }

            for(let i=0; i<16; i++) {
                let imgData = null;
                let groupIdx = -1;
                if (window.currentMode === 'single') { imgData = window.groupImages[0]; groupIdx = 0; }
                else if (window.currentMode === 'unique') { imgData = window.groupImages[i]; groupIdx = i; }
                else { groupIdx = window.cellGroups[i]; imgData = window.groupImages[groupIdx]; }
                updateCell(i, imgData, groupIdx);
            }
            refreshButtonPreviews();
        }

        function updateCell(index, imgData, groupIdx) {
            const cell = document.getElementById(`cell-${index}`);
            const img = cell.querySelector('.img-container img.source-image');
            const currentUrl = img.getAttribute('src');
            const newUrl = (imgData && imgData.url) ? imgData.url : '';
            if (currentUrl === newUrl && window.cropperInstances[index]) return;
            if (window.cropperInstances[index]) { window.cropperInstances[index].destroy(); window.cropperInstances[index] = null; }

            if (newUrl) {
                img.src = newUrl; img.style.display = 'block';
                cell.classList.add('has-image'); // Show controls
                const cropper = new Cropper(img, {
                    aspectRatio: stickerW / stickerH, viewMode: 1, dragMode: 'move', autoCropArea: 1, restore: false, guides: false, center: false, highlight: false, cropBoxMovable: false, cropBoxResizable: false, toggleDragModeOnDblclick: false, minContainerWidth: 100, minContainerHeight: 75, checkCrossOrigin: false, modal: false, background: false,
                    ready: function() {
                        this.cropper.isCustomReady = true;
                        if (imgData.canvasData) try { this.cropper.setCanvasData(imgData.canvasData); } catch(e) {}
                        if (imgData.cropBoxData) try { this.cropper.setCropBoxData(imgData.cropBoxData); } catch(e) {}
                    },
                    crop: function(event) {
                        if (!isSyncing && this.cropper.isCustomReady) {
                            if (syncFrameId) cancelAnimationFrame(syncFrameId);
                            syncFrameId = requestAnimationFrame(() => {
                                try {
                                    const cropData = this.cropper.getData();
                                    const canvasData = this.cropper.getCanvasData();
                                    const cropBoxData = this.cropper.getCropBoxData();
                                    if (window.groupImages[groupIdx]) {
                                        window.groupImages[groupIdx].cropData = cropData;
                                        window.groupImages[groupIdx].canvasData = canvasData;
                                        window.groupImages[groupIdx].cropBoxData = cropBoxData;
                                    }
                                    syncCrops(index, groupIdx, cropData);
                                } catch(e) { isSyncing=false; }
                            });
                        }
                    }
                });
                window.cropperInstances[index] = cropper; cropper.isCustomReady = false;
            } else {
                img.style.display = 'none';
                img.src = '';
                cell.classList.remove('has-image'); // Hide controls
            }
        }
        
        function syncCrops(sourceCellIndex, groupIdx, cropData) {
            isSyncing = true;
            for (let i = 0; i < 16; i++) {
                const target = window.cropperInstances[i];
                if (i !== sourceCellIndex && window.cellGroups[i] === groupIdx && target && target.isCustomReady) {
                    try { target.setData(cropData); } catch(e) {
                        console.warn('Failed to sync crop data to cell', i, e);
                    }
                }
            }
            isSyncing = false;
        }

        // Zoom controls for individual cells
        window.zoomCell = function(cellIndex, delta) {
            const cropper = window.cropperInstances[cellIndex];
            if (!cropper || !cropper.isCustomReady) return;

            try {
                const containerData = cropper.getContainerData();
                const canvasData = cropper.getCanvasData();
                const currentZoom = canvasData.width / canvasData.naturalWidth;
                const newZoom = Math.max(0.1, Math.min(3, currentZoom + delta));

                cropper.zoomTo(newZoom);
            } catch(e) {
                console.warn('Zoom failed:', e);
            }
        }

        // Fullscreen crop modal
        let fullscreenCellIndex = null;
        let fullscreenCropper = null;

        window.openFullscreenCrop = function(cellIndex) {
            const cropper = window.cropperInstances[cellIndex];
            if (!cropper || !cropper.isCustomReady) return;

            fullscreenCellIndex = cellIndex;
            const modal = document.getElementById('fullscreen-crop-modal');
            const img = document.getElementById('fullscreen-crop-image');
            const cell = document.getElementById(`cell-${cellIndex}`);
            const sourceImg = cell.querySelector('.source-image');

            // Set image source
            img.src = sourceImg.src;

            // Show modal
            modal.classList.add('active');

            // Initialize cropper in modal
            setTimeout(() => {
                if (fullscreenCropper) {
                    fullscreenCropper.destroy();
                }

                const groupIdx = window.cellGroups[cellIndex];
                const imgData = window.groupImages[groupIdx];

                fullscreenCropper = new Cropper(img, {
                    aspectRatio: stickerW / stickerH,
                    viewMode: 1,
                    dragMode: 'move',
                    autoCropArea: 1,
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: true,
                    cropBoxMovable: false,
                    cropBoxResizable: false,
                    toggleDragModeOnDblclick: false,
                    checkCrossOrigin: false,
                    ready: function() {
                        // Restore saved crop data - prefer relative cropData for cross-container compatibility
                        if (imgData && imgData.cropData) {
                            try { this.cropper.setData(imgData.cropData); } catch(e) {
                                console.warn('Failed to restore cropData, trying fallback', e);
                                // Fallback to absolute data if relative fails
                                if (imgData.canvasData) {
                                    try { this.cropper.setCanvasData(imgData.canvasData); } catch(e2) {}
                                }
                                if (imgData.cropBoxData) {
                                    try { this.cropper.setCropBoxData(imgData.cropBoxData); } catch(e2) {}
                                }
                            }
                        } else if (imgData && imgData.canvasData) {
                            // Legacy: restore using absolute data
                            try { this.cropper.setCanvasData(imgData.canvasData); } catch(e) {}
                            if (imgData.cropBoxData) {
                                try { this.cropper.setCropBoxData(imgData.cropBoxData); } catch(e) {}
                            }
                        }
                        updateFullscreenZoomDisplay();
                    },
                    zoom: function() {
                        updateFullscreenZoomDisplay();
                    }
                });
            }, 100);
        }

        window.closeFullscreenCrop = function() {
            if (fullscreenCropper && fullscreenCellIndex !== null) {
                try {
                    // Get crop data relative to the original image (not container-specific)
                    const cropData = fullscreenCropper.getData();
                    const canvasData = fullscreenCropper.getCanvasData();
                    const cropBoxData = fullscreenCropper.getCropBoxData();
                    const groupIdx = window.cellGroups[fullscreenCellIndex];

                    // Update the group image data with both relative and absolute data
                    if (window.groupImages[groupIdx]) {
                        window.groupImages[groupIdx].cropData = cropData;
                        window.groupImages[groupIdx].canvasData = canvasData;
                        window.groupImages[groupIdx].cropBoxData = cropBoxData;
                    }

                    // Apply to all croppers in the same group using relative data
                    isSyncing = true;
                    for (let i = 0; i < 16; i++) {
                        const target = window.cropperInstances[i];
                        if (window.cellGroups[i] === groupIdx && target && target.isCustomReady) {
                            try {
                                // Use setData with relative crop data for cross-container compatibility
                                target.setData(cropData);
                            } catch(e) {
                                console.warn('Failed to apply crop data to cell', i, e);
                            }
                        }
                    }
                    isSyncing = false;

                    fullscreenCropper.destroy();
                    fullscreenCropper = null;
                } catch(e) {
                    console.warn('Error closing fullscreen crop:', e);
                }
            }

            document.getElementById('fullscreen-crop-modal').classList.remove('active');
            fullscreenCellIndex = null;
        }

        window.zoomFullscreenCrop = function(delta) {
            if (!fullscreenCropper) return;

            try {
                const containerData = fullscreenCropper.getContainerData();
                const canvasData = fullscreenCropper.getCanvasData();
                const currentZoom = canvasData.width / canvasData.naturalWidth;
                const newZoom = Math.max(0.1, Math.min(3, currentZoom + delta));

                fullscreenCropper.zoomTo(newZoom);
                updateFullscreenZoomDisplay();
            } catch(e) {
                console.warn('Zoom failed:', e);
            }
        }

        window.resetFullscreenCrop = function() {
            if (!fullscreenCropper) return;
            fullscreenCropper.reset();
            updateFullscreenZoomDisplay();
        }

        function updateFullscreenZoomDisplay() {
            if (!fullscreenCropper) return;

            try {
                const canvasData = fullscreenCropper.getCanvasData();
                const zoom = canvasData.width / canvasData.naturalWidth;
                const zoomPercent = Math.round(zoom * 100);
                document.getElementById('fullscreen-zoom-display').textContent = zoomPercent + '%';
            } catch(e) {
                document.getElementById('fullscreen-zoom-display').textContent = '100%';
            }
        }

        window.resetCrop = function(groupIdx) {
            isSyncing = true;
            if(window.groupImages[groupIdx]) { 
                window.groupImages[groupIdx].canvasData = null; 
                window.groupImages[groupIdx].cropBoxData = null; 
            }
            for (let i = 0; i < 16; i++) { 
                if (window.cellGroups[i] === groupIdx && window.cropperInstances[i]) {
                    window.cropperInstances[i].reset(); 
                }
            }
            isSyncing = false;
        }

        function refreshButtonPreviews() {
            const buttons = document.querySelectorAll('.btn-upload');
            buttons.forEach((btn, idx) => {
                let existingPreview = btn.parentElement.querySelector('.btn-preview');
                if (!existingPreview) { existingPreview = document.createElement('img'); existingPreview.className = 'btn-preview'; btn.parentElement.prepend(existingPreview); }
                if (window.groupImages[idx] && window.groupImages[idx].url) { existingPreview.src = window.groupImages[idx].url; existingPreview.style.display = 'block'; } 
                else { existingPreview.style.display = 'none'; }
            });
        }

        window.setMode = function(mode) {
            window.currentMode = mode;
            document.querySelectorAll('.mode-selector button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            
            // Set dynamic grid attribute
            document.getElementById('upload-inputs').setAttribute('data-mode', mode);
            uploadContainer.innerHTML = '';
            
            let inputCount = (mode === 'quad') ? 4 : (mode === 'unique' ? 16 : 1);
            
            const oldImages = [...window.groupImages];
            window.groupImages = new Array(inputCount).fill(null);
            for(let i=0; i<Math.min(oldImages.length, inputCount); i++) { window.groupImages[i] = oldImages[i]; }
            
            for(let i=0; i<inputCount; i++) {
                const wrapper = document.createElement('div'); wrapper.className = 'file-input-wrapper'; wrapper.draggable = true; wrapper.dataset.index = i;
                wrapper.addEventListener('dragstart', handleDragStart); wrapper.addEventListener('dragover', handleDragOver); wrapper.addEventListener('dragleave', handleDragLeave); wrapper.addEventListener('drop', handleDrop); wrapper.addEventListener('dragend', handleDragEnd);
                
                const btn = document.createElement('div'); btn.className = 'btn-upload';
                
                // --- X BUTTON (DELETE) ---
                const delBtn = document.createElement('div'); 
                delBtn.className = 'btn-delete'; 
                delBtn.innerHTML = '<i class="fas fa-times"></i>'; 
                delBtn.title = 'Remove Image';
                delBtn.onclick = (e) => { 
                    e.stopPropagation(); 
                    window.clearImage(i); 
                };
                
                const refreshIconBox = document.createElement('div');
                refreshIconBox.className = 'refresh-icon-box';
                refreshIconBox.innerHTML = '<i class="fas fa-sync"></i>'; 
                
                const labelText = document.createElement('span'); 
                if (mode === 'single') labelText.innerHTML = `Upload Files<br><small>(JPG, PNG, GIF)</small>`;
                else if (mode === 'quad') labelText.innerHTML = `Upload Group ${i+1}<br><small>(JPG, PNG, GIF)</small>`;
                else labelText.innerHTML = `Image ${i+1}`;
                
                btn.appendChild(refreshIconBox);
                btn.appendChild(labelText); 
                btn.appendChild(delBtn); 
                
                const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/png, image/jpeg, image/gif, image/webp, video/webm';
                input.onchange = (e) => window.handleUpload(e, i);
                wrapper.appendChild(btn); wrapper.appendChild(input); uploadContainer.appendChild(wrapper);
            }
            refreshGrid();
        }

        window.handleUpload = function(event, inputIndex) {
            const file = event.target.files[0]; if(!file) return;
            if (window.groupImages[inputIndex] && window.groupImages[inputIndex].url) URL.revokeObjectURL(window.groupImages[inputIndex].url);
            window.groupImages[inputIndex] = { url: URL.createObjectURL(file), canvasData: null, cropBoxData: null };
            refreshGrid();
        }

        window.handleBulkUpload = function(event) {
            const files = Array.from(event.target.files); if(files.length === 0) return;
            if (files.length === 1) window.setMode('single'); else if (files.length <= 4) window.setMode('quad'); else window.setMode('unique');
            setTimeout(() => {
                files.slice(0, 16).forEach((file, index) => {
                   if (index < window.groupImages.length) {
                       if (window.groupImages[index] && window.groupImages[index].url) URL.revokeObjectURL(window.groupImages[index].url);
                       window.groupImages[index] = { url: URL.createObjectURL(file), canvasData: null, cropBoxData: null };
                   }
                });
                refreshGrid();
            }, 0);
        }

        function handleDragStart(e) { this.classList.add('dragging'); dragSrcIndex = parseInt(this.dataset.index); e.dataTransfer.effectAllowed = 'move'; }
        function handleDragOver(e) { if (e.preventDefault) e.preventDefault(); this.classList.add('drag-over'); e.dataTransfer.dropEffect = 'move'; return false; }
        function handleDragLeave(e) { this.classList.remove('drag-over'); }
        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation(); this.classList.remove('drag-over');
            const dragDestIndex = parseInt(this.dataset.index);
            if (dragSrcIndex !== null && dragSrcIndex !== dragDestIndex) {
                const temp = window.groupImages[dragSrcIndex]; window.groupImages[dragSrcIndex] = window.groupImages[dragDestIndex]; window.groupImages[dragDestIndex] = temp;
                refreshGrid();
            }
            return false;
        }
        function handleDragEnd(e) { this.classList.remove('dragging'); document.querySelectorAll('.file-input-wrapper').forEach(col => { col.classList.remove('drag-over'); }); }

        window.toggleOverlay = function() {
            const show = document.getElementById('toggle-overlay').checked;
            document.querySelectorAll('.overlay').forEach(o => { show ? o.classList.add('visible') : o.classList.remove('visible'); });
        }
        
        window.changeBackground = function(value) {
            if (value === 'custom') { document.getElementById('custom-bg-input').click(); }
            else if (value === 'none') { bgLayer.style.backgroundImage = 'none'; }
            else if (bgPatterns[value]) { bgLayer.style.backgroundImage = `url("${bgPatterns[value]}")`; }
        }

        function urlToBase64(url) {
            return fetch(url).then(res => res.blob()).then(blob => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            });
        }

        window.saveProject = async function() {
            const loadingOverlay = document.getElementById('loading-overlay');
            try {
                loadingOverlay.style.display = 'flex';
                const stamps = [];
                document.querySelectorAll('#stamp-layer .stamp-wrapper').forEach(el => {
                    const st = window.getComputedStyle(el); const tr = st.getPropertyValue("transform");
                    let angle = 0; if (tr && tr !== 'none') { const values = tr.split('(')[1].split(')')[0].split(','); angle = Math.round(Math.atan2(values[1], values[0]) * (180/Math.PI)); }
                    const content = el.querySelector('.stamp-content');
                    stamps.push({
                        text: content.innerText, left: parseFloat(el.style.left), top: parseFloat(el.style.top),
                        size: content.style.fontSize, rotation: angle,
                        isText: el.dataset.isText === 'true', font: el.dataset.font, color: el.dataset.color
                    });
                });

                const savedImages = [];
                for (let i = 0; i < window.groupImages.length; i++) {
                    if (window.groupImages[i] && window.groupImages[i].url) {
                        try { const b64 = await urlToBase64(window.groupImages[i].url); savedImages[i] = { b64: b64, canvasData: window.groupImages[i].canvasData, cropBoxData: window.groupImages[i].cropBoxData }; } catch (e) { savedImages[i] = null; }
                    } else { savedImages[i] = null; }
                }
                const projectData = {
                    theme: document.body.getAttribute('data-theme'), // Use data attribute
                    bgValue: document.getElementById('bg-select').value,
                    paperSize: document.getElementById('paper-size').value,
                    mode: window.currentMode, images: savedImages, stamps: stamps
                };
                const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'snap-station-project.json';
                a.click();
                URL.revokeObjectURL(url);
                showToast('Project saved successfully!');
            } catch(err) {
                console.error('Project save error:', err);
                showToast('Failed to save project - file may be too large');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }

        window.loadProject = function(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Validate project structure
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid project format');
                    }

                    if (data.theme) { document.getElementById('theme-select').value = data.theme; changeTheme(data.theme); }
                    if (data.bgValue) { document.getElementById('bg-select').value = data.bgValue; changeBackground(data.bgValue); }
                    if (data.paperSize) { document.getElementById('paper-size').value = data.paperSize; changePaperSize(data.paperSize); }
                    if (data.mode) window.setMode(data.mode);

                    if (Array.isArray(data.images)) {
                        window.groupImages.forEach(g => { if(g && g.url && g.url.startsWith('blob:')) URL.revokeObjectURL(g.url); });
                        window.groupImages = new Array(data.images.length).fill(null);
                        setTimeout(() => {
                            data.images.forEach((imgData, idx) => {
                                // Validate image data
                                if (imgData && imgData.b64 && typeof imgData.b64 === 'string' && imgData.b64.startsWith('data:')) {
                                    window.groupImages[idx] = { url: imgData.b64, canvasData: imgData.canvasData, cropBoxData: imgData.cropBoxData };
                                }
                            });
                            refreshGrid();
                        }, 100);
                    }

                    stampLayer.innerHTML = '';
                    if (Array.isArray(data.stamps)) {
                        data.stamps.forEach(s => {
                            if (s && s.text) {
                                createStamp(s.text, s.left, s.top, s.size, s.rotation, s.isText || false, s.font, s.color);
                            }
                        });
                    }

                    showToast('Project loaded successfully!');
                } catch (err) {
                    console.error('Project load error:', err);
                    showToast('Failed to load project - invalid or corrupted file');
                }
            };
            reader.readAsText(file); event.target.value = '';
        }

        window.saveOutput = async function() {
            const format = document.getElementById('export-format').value;
            const loadingOverlay = document.getElementById('loading-overlay'); loadingOverlay.style.display = 'flex';
            document.body.classList.add('printing'); 
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected')); activeStamp = null;

            const cells = document.querySelectorAll('.cell'); const tempImages = [];
            let gifWorkerUrl = null;
            if(format === 'gif') {
                try {
                    const blob = await fetch('lib/gif.worker.js').then(r => r.blob());
                    gifWorkerUrl = URL.createObjectURL(blob);
                } catch(e) {
                    console.warn('GIF worker load failed, using direct path', e);
                    gifWorkerUrl = 'lib/gif.worker.js';
                }
            }

            if(format !== 'gif') {
                cells.forEach((cell, index) => {
                    const cropper = window.cropperInstances[index];
                    if (cropper) { 
                        // Get cropped canvas without forced dimensions to preserve actual crop
                        const canvas = cropper.getCroppedCanvas({ 
                            imageSmoothingQuality: 'high',
                            fillColor: '#fff'
                        });
                        if (canvas) {
                            const img = document.createElement('img'); 
                            img.src = canvas.toDataURL('image/png'); 
                            img.className = 'temp-print-image';
                            // Ensure styles are explicit
                            img.style.cssText = 'width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;';
                            
                            const container = cell.querySelector('.img-container'); 
                            const cropperDiv = container.querySelector('.cropper-container');
                            if(cropperDiv) cropperDiv.style.display = 'none'; 
                            container.appendChild(img); 
                            tempImages.push({ container, img, cropperDiv });
                        }
                    }
                });
            } else {
                cells.forEach((cell, index) => {
                    const cropper = window.cropperInstances[index];
                    if (cropper) {
                        const container = cell.querySelector('.img-container'); const sourceImg = container.querySelector('.source-image'); const cropperDiv = container.querySelector('.cropper-container');
                        const cropData = cropper.getData(); const containerRect = container.getBoundingClientRect(); const scale = containerRect.width / cropData.width;
                        const wrapper = document.createElement('div'); wrapper.style.cssText = 'width:100%;height:100%;overflow:hidden;position:relative;'; wrapper.className = 'temp-gif-wrapper';
                        const animImg = sourceImg.cloneNode(true); animImg.style.cssText = `display:block;position:absolute;width:${sourceImg.naturalWidth * scale}px;height:${sourceImg.naturalHeight * scale}px;left:${-cropData.x * scale}px;top:${-cropData.y * scale}px;max-width:none;max-height:none;`;
                        if (cell.classList.contains('weathered-active')) animImg.classList.add('temp-weathered');
                        if(cropperDiv) cropperDiv.style.display = 'none'; wrapper.appendChild(animImg); container.appendChild(wrapper); tempImages.push({ container, img: wrapper, cropperDiv }); 
                    }
                });
            }

            await new Promise(resolve => setTimeout(resolve, 800)); 

            try {
                if (format === 'gif') {
                    const gifOptions = { workers: 2, quality: 10, width: paperElement.offsetWidth * 1.5, height: paperElement.offsetHeight * 1.5 };
                    if (gifWorkerUrl) { gifOptions.workerScript = gifWorkerUrl; }
                    const gif = new GIF(gifOptions);
                    const frameCount = 15;
                    for (let i = 0; i < frameCount; i++) {
                         const canvas = await html2canvas(paperElement, { scale: 1.5, useCORS: true, logging: false, backgroundColor: null });
                         gif.addFrame(canvas, {delay: 100}); await new Promise(r => setTimeout(r, 100));
                    }
                    gif.on('finished', function(blob) {
                         const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = 'snap-station-stickers.gif'; link.href = url; link.click();
                         tempImages.forEach(item => { item.img.remove(); if (item.cropperDiv) item.cropperDiv.style.display = ''; });
                         if(gifWorkerUrl) URL.revokeObjectURL(gifWorkerUrl); loadingOverlay.style.display = 'none'; document.body.classList.remove('printing');
                    });
                    gif.render(); return; 
                }
                
                const canvas = await html2canvas(paperElement, { scale: 3, useCORS: true });
                if (format === 'pdf') {
                    const imgData = canvas.toDataURL('image/png'); const docStyle = getComputedStyle(document.documentElement);
                    const pW = parseFloat(docStyle.getPropertyValue('--paper-width')); const pH = parseFloat(docStyle.getPropertyValue('--paper-height'));
                    const orientation = pW > pH ? 'landscape' : 'portrait';
                    const pdf = new jspdf.jsPDF({ orientation: orientation, unit: 'mm', format: [pW, pH] });
                    pdf.addImage(imgData, 'PNG', 0, 0, pW, pH); pdf.save('snap-station-stickers.pdf');
                } else {
                    const mimeType = format === 'jpg' ? 'image/jpeg' : (format === 'webp' ? 'image/webp' : 'image/png');
                    canvas.toBlob(blob => {
                         const link = document.createElement('a'); link.download = `snap-station-stickers.${format}`;
                         link.href = URL.createObjectURL(blob); link.click(); URL.revokeObjectURL(link.href);
                    }, mimeType, 0.95);
                }
            } catch (error) {
                console.error('Export error:', error);
                const errorMsg = error.message.includes('canvas') ? 'Failed to generate output - image may be too large' : 'Failed to generate output - please try a different format';
                showToast(errorMsg);
            } finally {
                if (format !== 'gif') { tempImages.forEach(item => { item.img.remove(); if (item.cropperDiv) item.cropperDiv.style.display = ''; }); loadingOverlay.style.display = 'none'; document.body.classList.remove('printing'); }
            }
        }

        // Print function for direct printing
        window.printStickers = function() {
            // Deselect any selected stamps
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected'));
            activeStamp = null;

            // Add print class to body for print-specific styles
            document.body.classList.add('printing');

            // Hide controls and UI elements during print
            const controlsEl = document.querySelector('.controls');
            const stampSelector = document.querySelector('.stamp-selector');
            const cuttingBtn = document.querySelector('button[onclick="downloadCuttingTemplate()"]');

            if (controlsEl) controlsEl.style.display = 'none';
            if (stampSelector) stampSelector.style.display = 'none';
            if (cuttingBtn) cuttingBtn.style.display = 'none';

            // Trigger browser print dialog
            setTimeout(() => {
                window.print();

                // Restore UI after print dialog closes
                setTimeout(() => {
                    document.body.classList.remove('printing');
                    if (controlsEl) controlsEl.style.display = '';
                    if (stampSelector) stampSelector.style.display = '';
                    if (cuttingBtn) cuttingBtn.style.display = '';
                }, 100);
            }, 100);
        }

        init();
    })();
</script>
<script>
    /* * ADVANCED PRINTER GAMEPAD SUPPORT 
     * Features: Spatial Nav, Analog Support, Contextual Modes, Grabbing
     */
    (function() {
        if (!window.navigator || !navigator.getGamepads) return;

        const PrinterGamepad = {
            gpIndex: null,
            lastButtons: [],
            focusedEl: null,
            elements: [],
            
            // Konami State
            konamiSeqGP: [12, 12, 13, 13, 14, 15, 14, 15, 1, 0, 9], // Up, Up, Down, Down, Left, Right, Left, Right, B, A, Start
            konamiIndexGP: 0,
            
            // State
            mode: 'MENU', // 'MENU', 'GRAB_STAMP'
            grabbedStamp: null,
            
            // Tuning
            deadzone: 0.5,
            navCooldown: 0,
            COOLDOWN_FRAMES: 8,
            moveSpeed: 5,

            // Visuals
            indicatorEl: document.getElementById('gp-mode-text'),
            indicatorContainer: document.getElementById('gp-indicator'),

            init: function() {
                window.addEventListener("gamepadconnected", (e) => { 
                    this.gpIndex = e.gamepad.index; 
                    this.startPolling(); 
                    this.showIndicator("Controller Connected");
                    this.refreshElements();
                    this.focusBestInitial();
                });
                window.addEventListener("gamepaddisconnected", (e) => { 
                    if (this.gpIndex === e.gamepad.index) { 
                        this.gpIndex = null; 
                        this.hideIndicator(); 
                    } 
                });
            },

            showIndicator: function(msg) {
                if(this.indicatorEl) this.indicatorEl.textContent = msg;
                if(this.indicatorContainer) this.indicatorContainer.classList.add('visible');
            },

            hideIndicator: function() {
                if(this.indicatorContainer) this.indicatorContainer.classList.remove('visible');
            },

            refreshElements: function() {
                // Gather all interactive elements
                const selectors = [
                    ".controls button", 
                    ".controls select", 
                    ".controls input", 
                    ".file-input-wrapper",
                    ".stamp-wrapper", // Stamps are navigable
                    ".modal-close",
                    "button[onclick*='downloadCuttingTemplate']"
                ];
                // Filter visible only
                this.elements = Array.from(document.querySelectorAll(selectors.join(",")))
                    .filter(el => {
                        const style = window.getComputedStyle(el);
                        return style.display !== 'none' && style.visibility !== 'hidden' && !el.disabled && el.offsetParent !== null;
                    });
            },

            focusBestInitial: function() {
                if (this.elements.length > 0) {
                    this.setFocus(this.elements[0]);
                }
            },

            setFocus: function(el) {
                if (this.focusedEl) {
                    this.focusedEl.classList.remove('gamepad-focus');
                    // Close stamp controls if leaving a stamp
                    if(this.focusedEl.classList.contains('stamp-wrapper')) {
                        this.focusedEl.classList.remove('selected');
                    }
                }
                this.focusedEl = el;
                if (this.focusedEl) {
                    this.focusedEl.classList.add('gamepad-focus');
                    this.focusedEl.focus({preventScroll: true});
                    this.focusedEl.scrollIntoView({behavior: 'smooth', block: 'center'});
                    
                    // Stamp Logic
                    if(this.focusedEl.classList.contains('stamp-wrapper')) {
                        this.focusedEl.classList.add('selected');
                        this.showIndicator("Stamp Selected (Press A to Grab)");
                    } else {
                        this.showIndicator("Menu Mode");
                    }
                }
            },

            startPolling: function() {
                const loop = () => {
                    if (this.gpIndex !== null) {
                        this.checkInput();
                        requestAnimationFrame(loop);
                    }
                };
                requestAnimationFrame(loop);
            },

            checkInput: function() {
                const gp = navigator.getGamepads()[this.gpIndex];
                if (!gp) return;

                // Konami Check
                this.checkKonami(gp);

                // 1. Context Switching (Grab Mode vs Menu Mode)
                if (this.mode === 'GRAB_STAMP' && this.grabbedStamp) {
                    this.handleGrabInput(gp);
                } else {
                    this.handleMenuInput(gp);
                }

                this.lastButtons = gp.buttons.map(b => ({ pressed: b.pressed }));
            },

            checkKonami: function(gp) {
                let pressedBtn = -1;
                for(let i=0; i<gp.buttons.length; i++) {
                    if (this.justPressed(gp, i)) {
                        pressedBtn = i;
                        break;
                    }
                }

                if (pressedBtn !== -1) {
                    if (pressedBtn === this.konamiSeqGP[this.konamiIndexGP]) {
                        this.konamiIndexGP++;
                        if (this.konamiIndexGP === this.konamiSeqGP.length) {
                            if(window.unlock1UpTheme) window.unlock1UpTheme();
                            this.konamiIndexGP = 0;
                        }
                    } else {
                        this.konamiIndexGP = 0; 
                         if (pressedBtn === this.konamiSeqGP[0]) {
                            this.konamiIndexGP = 1;
                        }
                    }
                }
            },

            handleMenuInput: function(gp) {
                // Cooldown for nav
                if (this.navCooldown > 0) this.navCooldown--;

                // --- Directional Input (D-Pad + Analog) ---
                let dx = 0, dy = 0;
                
                // D-Pad
                if (gp.buttons[12].pressed) dy = -1; // Up
                if (gp.buttons[13].pressed) dy = 1;  // Down
                if (gp.buttons[14].pressed) dx = -1; // Left
                if (gp.buttons[15].pressed) dx = 1;  // Right

                // Analog Stick (Axis 0, 1) with Deadzone
                if (Math.abs(gp.axes[0]) > this.deadzone) dx = gp.axes[0];
                if (Math.abs(gp.axes[1]) > this.deadzone) dy = gp.axes[1];

                // Execute Move if Cooldown ready and input exists
                if (this.navCooldown === 0 && (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5)) {
                    this.moveFocusGeometric(dx, dy);
                    this.navCooldown = this.COOLDOWN_FRAMES;
                }

                // --- Buttons ---
                // A (0) - Select / Grab
                if (this.justPressed(gp, 0)) {
                    if (this.focusedEl) {
                        if (this.focusedEl.classList.contains('stamp-wrapper')) {
                            // Enter Grab Mode
                            this.mode = 'GRAB_STAMP';
                            this.grabbedStamp = this.focusedEl;
                            this.grabbedStamp.classList.add('grabbed');
                            this.showIndicator("Grabbing Stamp (A to Drop, B to Delete)");
                        } else {
                            // Normal Click
                            this.focusedEl.click();
                        }
                    }
                }

                // B (1) - Back / Close Modal
                if (this.justPressed(gp, 1)) {
                    const visibleModal = document.querySelector('.modal-overlay[style*="display: flex"]');
                    if (visibleModal) {
                        // Find close button
                        const closeBtn = visibleModal.querySelector('.modal-close');
                        if (closeBtn) closeBtn.click();
                    } else if (this.focusedEl && this.focusedEl.classList.contains('stamp-wrapper')) {
                         // Deselect Stamp
                         this.focusedEl.classList.remove('selected');
                         // Find nearest non-stamp element to retreat to? Or just stay focused.
                    }
                }
            },

            handleGrabInput: function(gp) {
                // Movement logic for Stamp
                let dx = 0, dy = 0;
                
                // D-Pad
                if (gp.buttons[12].pressed) dy = -1;
                if (gp.buttons[13].pressed) dy = 1;
                if (gp.buttons[14].pressed) dx = -1;
                if (gp.buttons[15].pressed) dx = 1;

                // Analog
                if (Math.abs(gp.axes[0]) > this.deadzone) dx = gp.axes[0];
                if (Math.abs(gp.axes[1]) > this.deadzone) dy = gp.axes[1];

                // Chording: Hold L1 (Btn 4) to speed up
                let speed = this.moveSpeed;
                if (gp.buttons[4].pressed) speed *= 3; 

                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                    const rect = this.grabbedStamp.getBoundingClientRect();
                    const parentRect = this.grabbedStamp.offsetParent.getBoundingClientRect();
                    
                    // Convert current left/top to pixels relative to parent
                    let currentLeft = parseFloat(this.grabbedStamp.style.left) || (rect.left - parentRect.left);
                    let currentTop = parseFloat(this.grabbedStamp.style.top) || (rect.top - parentRect.top);

                    this.grabbedStamp.style.left = (currentLeft + dx * speed) + 'px';
                    this.grabbedStamp.style.top = (currentTop + dy * speed) + 'px';
                }

                // A (0) - Drop
                if (this.justPressed(gp, 0)) {
                    this.mode = 'MENU';
                    this.grabbedStamp.classList.remove('grabbed');
                    this.grabbedStamp = null;
                    this.showIndicator("Stamp Dropped");
                }

                // B (1) - Delete
                if (this.justPressed(gp, 1)) {
                    this.grabbedStamp.remove();
                    this.mode = 'MENU';
                    this.grabbedStamp = null;
                    this.refreshElements();
                    this.focusBestInitial();
                    this.showIndicator("Stamp Deleted");
                }
            },

            // --- Geometric Navigation Logic ---
            moveFocusGeometric: function(dx, dy) {
                this.refreshElements(); // Ensure list is up to date
                
                if (!this.focusedEl) {
                    this.focusBestInitial();
                    return;
                }

                const currentRect = this.focusedEl.getBoundingClientRect();
                const cx = currentRect.left + currentRect.width / 2;
                const cy = currentRect.top + currentRect.height / 2;

                let bestCandidate = null;
                let minScore = Infinity;

                // Normalize direction vector
                const mag = Math.sqrt(dx*dx + dy*dy);
                const ndx = dx / mag;
                const ndy = dy / mag;

                for (let el of this.elements) {
                    if (el === this.focusedEl) continue;

                    const rect = el.getBoundingClientRect();
                    const tcx = rect.left + rect.width / 2;
                    const tcy = rect.top + rect.height / 2;

                    // Vector to target
                    const vbx = tcx - cx;
                    const vby = tcy - cy;
                    const dist = Math.sqrt(vbx*vbx + vby*vby);

                    // Project vector onto direction (Dot Product)
                    const dot = vbx * ndx + vby * ndy;

                    // Must be in the general direction (dot product > 0)
                    // We can be stricter (e.g., > 0.5) to prevent moving sideways when pressing up
                    if (dot <= 0) continue; 

                    // Calculate perpendicular distance (rejection)
                    // How far "off track" is this element?
                    // We want elements close to the movement axis.
                    // Rejection vector magnitude:
                    // dist^2 = dot^2 + rej^2  => rej^2 = dist^2 - dot^2
                    const rejSq = (dist*dist) - (dot*dot);
                    
                    // Score: We want low distance, high alignment
                    // Weight perpendicular distance heavily
                    const score = dist + (rejSq * 2); 

                    if (score < minScore) {
                        minScore = score;
                        bestCandidate = el;
                    }
                }

                if (bestCandidate) {
                    this.setFocus(bestCandidate);
                }
            },

            justPressed: function(gp, btnIndex) {
                return gp.buttons[btnIndex].pressed && !(this.lastButtons[btnIndex] && this.lastButtons[btnIndex].pressed);
            }
        };

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", () => PrinterGamepad.init());
        } else {
            PrinterGamepad.init();
        }
    })();
</script>
</body>
</html>