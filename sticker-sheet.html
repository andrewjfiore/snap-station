<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="gamepad=(self), clipboard-read=(self)">

    <title>Sticker Sheet Creator</title>
    <!-- External Libs -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- GIF Encoder -->
    <script src="lib/gif.js"></script>
    
    <!-- Fonts for Stamps (Google Fonts) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Pacifico&family=Permanent+Marker&family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <style>
        /* --- CORE VARIABLES --- */
        :root {
            /* Dimensions */
            --paper-width: 152.4mm;
            --paper-height: 101.6mm;
            --cell-width: 26.6mm;
            --cell-height: 20mm;
            --gap: 1mm;
            --grid-width: calc((var(--cell-width) * 4) + (var(--gap) * 3));
            --grid-height: calc((var(--cell-height) * 4) + (var(--gap) * 3));

            /* Video Rental Palette */
            --bg: #1d2c5e;         /* Deep Blue Main BG */
            --light-blue: #2a4480; /* Intermediary Blue for Containers */
            --text: #ffffff;
            --border: #ffcb05;     /* Video Rental Yellow */
            --accent: #ffcb05;
            --btn-hover: #c7a008;
            --btn-bg: #1d2c5e;     /* Dark button bg */
            --purple-btn: #6f42c1;
            --green-btn: #28a745;
            --red-btn: #dc3545;
        }

        /* --- THEME DEFINITIONS --- */
        [data-theme="video-rental"] { --bg: #1d2c5e; --light-blue: #2a4480; --panel: #1d2c5e; --text: #ffffff; --border: #ffcb05; --accent: #ffcb05; --btn-hover: #c7a008; --btn-bg: #1d2c5e; }
        [data-theme="dark"] { --bg: #1a1e23; --light-blue: #2d333b; --text: #e6e6e6; --border: #444c56; --accent: #444c56; --btn-hover: #444c56; --btn-bg: #373e47; }
        [data-theme="light"] { --bg: #e0e0e0; --light-blue: #ffffff; --text: #333333; --border: #cccccc; --accent: #007bff; --btn-hover: #0056b3; --btn-bg: #f8f9fa; }
        
        /* Updated Retro Theme */
        [data-theme="retro"] { 
            --bg: #01009a; 
            --light-blue: #f5b201; /* Mustard Yellow */
            --panel: #f5b201; 
            --text: #ffffff;       /* Changed to White */
            --border: #e10916; 
            --accent: #329900; 
            --btn-hover: #e10916; 
            --btn-bg: #ffffff; 
        }

        [data-theme="hearts"] { --bg: #FFB6C1; --light-blue: #fff0f5; --text: #8b1a4a; --border: #ff69b4; --accent: #ff1493; --btn-hover: #ff69b4; --btn-bg: #ffffff; }
        [data-theme="vines"] { --bg: #C1FFB6; --light-blue: #e8f5e9; --text: #1a3d18; --border: #4caf50; --accent: #388e3c; --btn-hover: #4caf50; --btn-bg: #ffffff; }
        [data-theme="1-up"] { 
            --bg: #5c94fc; 
            --light-blue: #c84c0c; 
            --panel: #c84c0c; 
            --text: #ffffff; 
            --border: #000000; 
            --accent: #fca044; 
            --btn-hover: #e45c10; 
            --btn-bg: #c84c0c; 
            
            /* Override colors for 1-UP specifically */
            --purple-btn: #c84c0c; 
            --green-btn: #c84c0c; 
            --red-btn: #c84c0c; 
        }

        /* Unified Theme Button Text Color Fixes */
        [data-theme="light"] button,
        [data-theme="light"] .btn-primary { 
            color: #333; 
        }
        /* Removed Retro button override to allow it to inherit white text */
        
        [data-theme="hearts"] button,
        [data-theme="vines"] button { 
            color: var(--text); 
            border-color: var(--border); 
        }
        
        /* Force 1-UP buttons to use theme border and text color (White on Brick Red) */
        [data-theme="1-up"] .btn-purple,
        [data-theme="1-up"] .btn-green,
        [data-theme="1-up"] .btn-delete,
        [data-theme="1-up"] .btn-stamp-add {
            background-color: var(--light-blue);
            color: var(--text);
            border-color: var(--border);
        }

        /* --- GLOBAL STYLES --- */
        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            transition: background-color 0.3s ease;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        h1 { display: none; } 

        .controls {
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- BOX STYLES --- */
        .control-section {
            background: var(--light-blue); 
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        /* Settings Row */
        .settings-row { display: flex; gap: 20px; flex-wrap: wrap; }
        .setting-group { flex: 1; display: flex; flex-direction: column; gap: 8px; min-width: 150px; }
        .setting-group label { font-weight: 700; font-size: 0.95rem; color: var(--text); }
        select {
            background-color: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 6px;
            font-weight: 500;
            outline: none;
            cursor: pointer;
            width: 100%;
            font-family: inherit;
        }
        option { background-color: #333; color: white; } /* Fix for white-on-white in some browsers */
        [data-theme="light"] option { background-color: #fff; color: #333; }

        /* Project Buttons */
        .project-buttons { display: flex; gap: 15px; flex-wrap: wrap; }
        .btn-project {
            flex: 1;
            background: var(--bg);
            color: white; /* Forced white text per request */
            border: 1px solid var(--border);
            padding: 12px;
            border-radius: 6px;
            font-weight: 700;
            display: flex; align-items: center; justify-content: center; gap: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit; 
            min-width: 180px;
        }
        [data-theme="light"] .btn-project { color: #333; } /* Exception for light theme readability */
        
        .btn-project:hover { border-color: var(--text); transform: translateY(-1px); }
        .emoji-icon { font-size: 1.3rem; line-height: 1; }

        /* Mode Selector */
        .mode-selector { display: flex; gap: 20px; margin-bottom: 25px; }
        .mode-selector button {
            flex: 1;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 12px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            font-family: inherit;
        }
        .mode-selector button.active {
            background-color: var(--accent);
            color: #1d2c5e; 
            border-color: var(--accent);
        }
        /* Retro theme fix for active button text */
        [data-theme="retro"] .mode-selector button.active {
            color: #fff;
        }

        /* --- UPLOAD AREA --- */
        .upload-area { display: grid; gap: 15px; margin-bottom: 25px; width: 100%; }
        .upload-area[data-mode="single"] { grid-template-columns: 200px; justify-content: center; }
        .upload-area[data-mode="quad"] { grid-template-columns: repeat(4, 1fr); }
        .upload-area[data-mode="unique"] { grid-template-columns: repeat(4, 1fr); }

        .file-input-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 26.6 / 20; 
            border: 2px dashed var(--border);
            border-radius: 8px;
            box-sizing: border-box;
            overflow: hidden;
            background: rgba(0,0,0,0.1);
        }
        .file-input-wrapper input[type=file] {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            opacity: 0; cursor: pointer; z-index: 20;
        }
        .btn-upload {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: none; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; background: transparent; color: var(--text);
            box-sizing: border-box; padding: 5px;
            z-index: 15; pointer-events: none;
        }
        .btn-upload .btn-mini-action, .btn-upload .refresh-icon-box { pointer-events: auto; }

        .refresh-icon-box {
            border: 1px solid var(--border); width: 30px; height: 30px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px; margin-bottom: 5px; font-size: 0.9rem;
        }
        .btn-upload span { font-size: 0.8rem; line-height: 1.1; font-weight: 500; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
        .btn-upload small { font-size: 0.6rem; opacity: 0.8; margin-top: 2px; display: block; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
        
        .btn-preview {
            width: 100%; height: 100%; object-fit: cover;
            border-radius: 6px; display: none;
            position: absolute; top:0; left:0; z-index: 10;
        }
        
        /* Delete Button in Square */
        .btn-delete {
            width: 24px; height: 24px; font-size: 14px;
            background: var(--red-btn); border: 1px solid white;
            color: white; border-radius: 50%;
            position: absolute; top: 5px; right: 5px; z-index: 30;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transition: transform 0.2s;
            pointer-events: auto;
        }
        .btn-delete:hover { transform: scale(1.1); filter: brightness(1.1); }

        /* Action Bar */
        .action-bar {
            display: flex; align-items: center; justify-content: space-between;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 203, 5, 0.3);
            flex-wrap: wrap; gap: 15px;
        }
        
        .help-btn {
            width: 32px; height: 32px;
            border: 2px solid var(--text); border-radius: 50%;
            background: transparent; color: var(--text);
            font-weight: bold; font-size: 1.2rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }

        .toggles { display: flex; gap: 20px; align-items: center; }
        .toggle-label { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 0.95rem; cursor: pointer; }
        .toggle-label input { width: 18px; height: 18px; accent-color: var(--text); cursor: pointer; }

        .actions-right { display: flex; gap: 15px; align-items: center; }

        .btn-purple {
            background-color: var(--purple-btn);
            color: white; border: none;
            padding: 10px 24px; border-radius: 6px; font-weight: 700;
            display: flex; align-items: center; gap: 8px; cursor: pointer;
            font-size: 1rem; font-family: inherit;
        }
        
        .save-group {
            display: flex; border-radius: 6px; overflow: hidden;
            background: var(--bg); border: 1px solid var(--border);
            align-items: center;
        }
        .save-group select {
            background: var(--bg); border: none; border-radius: 0; padding: 10px;
            color: var(--text); width: auto; cursor: pointer;
        }
        .save-separator { width: 1px; height: 24px; background-color: var(--border); margin: 0 5px; opacity: 0.5; }
        
        .btn-green {
            background-color: var(--green-btn); color: white;
            border: none; padding: 10px 24px; border-radius: 0;
            font-weight: 700; cursor: pointer; font-size: 1rem;
            font-family: inherit; height: 100%;
            display: flex; align-items: center; justify-content: center;
        }

        /* --- STAMP & EDITOR --- */
        .stamp-selector {
            background: var(--light-blue); border: 2px solid var(--border);
            border-radius: 8px; padding: 20px; width: 100%;
            max-width: 800px; box-sizing: border-box;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .stamp-selector label { font-weight: 800; margin-bottom: 12px; display: block; font-size: 1.1rem; }
        
        .stamp-list { 
            display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px; 
            overflow-x: hidden; /* No scrolling */
        }
        .btn-stamp-add { 
            font-size: 1.5rem; padding: 5px 10px; 
            background: var(--bg); border: 1px solid var(--border); color: var(--text);
            border-radius: 6px; cursor: pointer;
            min-width: 45px; text-align: center;
        }
        
        /* Custom Stamp Input */
        .custom-stamp-input {
            padding: 5px 10px; border: 1px solid var(--border); border-radius: 6px;
            background: var(--bg); color: var(--text); font-family: inherit;
            text-align: center; font-weight: bold; width: 150px;
        }
        .custom-stamp-input::placeholder { color: var(--text); opacity: 0.7; font-weight: normal; }
        
        .text-stamp-controls {
            border-top: 1px solid var(--border); padding-top: 15px;
            display: flex; gap: 10px; flex-wrap: wrap; align-items: center;
        }
        .text-input {
            flex: 2; padding: 10px; border-radius: 6px;
            border: 1px solid var(--border); background-color: var(--bg);
            color: var(--text); font-weight: 700; font-family: inherit;
        }
        
        #paper {
            width: var(--paper-width); height: var(--paper-height);
            background-color: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            position: relative; display: flex; justify-content: center; align-items: center;
            overflow: hidden; flex-shrink: 0; color: black;
            transition: width 0.3s, height 0.3s;
            margin-bottom: 20px;
        }
        
        #background-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; background-size: cover; background-position: center; }
        #stamp-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }

        .stamp-wrapper { position: absolute; cursor: grab; user-select: none; display: inline-block; line-height: 1; pointer-events: auto; transform-origin: center center; touch-action: none; }
        .stamp-wrapper:active { cursor: grabbing; }
        .stamp-content { font-size: 3rem; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); white-space: nowrap; }
        .stamp-wrapper.selected { z-index: 100; }
        .stamp-wrapper.selected .stamp-content { outline: 2px dashed var(--accent); background-color: rgba(255, 255, 255, 0.2); border-radius: 4px; }
        .stamp-wrapper.grabbed .stamp-content { outline: 3px solid #ff3333; cursor: grabbing; }
        
        .stamp-controls { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .stamp-wrapper.selected .stamp-controls { display: block; }
        
        .handle {
            position: absolute; width: 24px; height: 24px;
            background: white; border: 2px solid #333; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; font-weight: 800; cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3); color: #333; z-index: 101;
        }
        .handle:hover { background-color: #f0f0f0; transform: scale(1.1); }
        .handle-del { top: -12px; left: -12px; color: #ff3333; border-color: #ff3333; }
        .handle-rot { top: -12px; right: -12px; cursor: alias; }
        .handle-sz  { bottom: -12px; right: -12px; cursor: nwse-resize; }

        #sticker-grid {
            display: grid;
            grid-template-columns: repeat(4, var(--cell-width));
            grid-template-rows: repeat(4, var(--cell-height));
            gap: var(--gap);
            width: var(--grid-width); height: var(--grid-height);
            z-index: 1; pointer-events: none; 
        }

        .cell {
            width: var(--cell-width); height: var(--cell-height);
            position: relative; overflow: hidden; background: #eee; pointer-events: auto; 
        }
        .img-container { width: 100%; height: 100%; position: relative; }
        .img-container > img.source-image { width: 100%; height: 100%; object-fit: cover; display: block; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; opacity: 0; transition: opacity 0.2s;
        }
        .overlay.visible { opacity: 1; }
        .overlay path { fill: none; stroke: white; stroke-width: 0.8px; vector-effect: non-scaling-stroke; filter: drop-shadow(0px 0px 1px rgba(0,0,0,0.3)); }

        .cell-effect-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; opacity: 0; transition: opacity 0.2s; }
        .crt-cell-overlay { background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%); background-size: 100% 2px; mix-blend-mode: multiply; }
        .cell.crt-active .crt-cell-overlay { opacity: 1; }

        .cell.weathered-active img { filter: sepia(0.2) saturate(0.8) contrast(1.1) brightness(0.95); }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 2500;
            display: none; justify-content: center; align-items: center; flex-direction: column; color: white;
        }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #007bff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Modals - FIXED: Start hidden */
        .modal-overlay {
            display: none; /* Hidden by default */
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: rgba(0,0,0,0.6); 
            z-index: 2000; 
            justify-content: center; 
            align-items: center;
        }
        .modal-content {
            background: var(--light-blue); color: var(--text); padding: 30px; border-radius: 12px;
            max-width: 550px; width: 90%; max-height: 80vh; overflow-y: auto;
            position: relative; box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 4px solid var(--border);
        }
        .modal-close { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text); padding: 0; width: auto; height: auto; }

        /* Toast Notification */
        .toast-notification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: #fff; padding: 12px 24px;
            border-radius: 8px; font-size: 14px; z-index: 3000;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .toast-notification.visible { opacity: 1; }

        /* Gamepad Focus */
        .gamepad-focus { box-shadow: 0 0 0 4px var(--accent), 0 0 15px var(--accent) !important; transform: scale(1.02); z-index: 50; }
        .gamepad-mode-indicator {
            position: fixed; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.8); color: #fff; padding: 10px 15px;
            border-radius: 20px; border: 2px solid var(--accent);
            font-size: 0.8rem; z-index: 9999;
            display: flex; align-items: center; gap: 10px;
            opacity: 0; transition: opacity 0.3s;
        }
        .gamepad-mode-indicator.visible { opacity: 1; }

        /* Responsive */
        @media (max-width: 768px) {
            .upload-area[data-mode="quad"], .upload-area[data-mode="unique"] { grid-template-columns: repeat(2, 1fr); }
            .action-bar { justify-content: center; gap: 20px; }
            .toggles { flex-wrap: wrap; justify-content: center; }
            #paper { transform-origin: top center; transform: scale(0.8); margin-bottom: -20mm; }
        }
        @media (max-width: 480px) {
            .upload-area[data-mode="quad"], .upload-area[data-mode="unique"] { grid-template-columns: 1fr; }
            #paper { transform: scale(0.55); margin-bottom: -45mm; }
        }
        
        .emoji-wallpaper { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; overflow: hidden; opacity: 0; transition: opacity 0.5s ease; }
        .emoji-wallpaper.active { opacity: 1; }
        .emoji-wallpaper span { position: absolute; font-size: 24px; animation: float 8s ease-in-out infinite; opacity: 0.6; }
        @keyframes float { 0%, 100% { transform: translateY(0) rotate(0deg); } 50% { transform: translateY(-15px) rotate(10deg); } }
    </style>
</head>
<body data-theme="video-rental">

<div class="emoji-wallpaper" id="emojiWallpaper"></div>
<div id="gp-indicator" class="gamepad-mode-indicator"><span class="icon">ğŸ®</span><span id="gp-mode-text">Menu Mode</span></div>
<div id="toast" class="toast-notification">Notification Message</div>
<div id="loading-overlay"><div class="spinner"></div><p>Processing...</p></div>

<!-- HELP MODAL -->
<div id="help-modal" class="modal-overlay" onclick="toggleHelp()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <button class="modal-close" onclick="toggleHelp()">Ã—</button>
        <h2 style="margin-top:0;">User Guide</h2>
        <div class="guide-section">
            <h3>Layouts</h3>
            <ul>
                <li><strong>1 Photo (1x16):</strong> Repeats 1 image 16 times.</li>
                <li><strong>4 Photos (2x2 Grid):</strong> Fills 4 quadrants.</li>
                <li><strong>16 Unique Photos:</strong> Individual control for every sticker.</li>
            </ul>
        </div>
        <div class="guide-section">
            <h3>Editing</h3>
            <p><strong>Double-click</strong> any sticker to reset its zoom and position.</p>
        </div>
        <div class="guide-section">
            <h3>Cutting Template</h3>
            <p>The "Download Cutting Template (SVG)" button generates a vector file compatible with cutting plotters such as the <strong>CricutÂ®</strong> or <strong>Silhouetteâ„¢</strong>. This file contains the cut lines for the stickers.</p>
        </div>
        <div class="guide-section">
            <h3>Paste Images</h3>
            <p>Press <strong>Ctrl+V</strong> (or <strong>Cmd+V</strong>) anywhere to paste images from your clipboard.</p>
        </div>
    </div>
</div>

<div class="controls">
    
    <!-- 1. Top Settings -->
    <div class="control-section">
        <div class="settings-row">
            <div class="setting-group">
                <label>Theme:</label>
                <select id="theme-select" onchange="changeTheme(this.value)">
                    <optgroup label="Color Themes">
                        <option value="video-rental" selected>Video Rental</option>
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                        <option value="retro">Retro</option>
                        <option value="1-up" hidden disabled id="theme-1up-option">ğŸ„ 1-UP</option>
                    </optgroup>
                    <optgroup label="Wallpaper Themes">
                        <option value="hearts">Hearts & Bubbles ğŸ’–</option>
                        <option value="vines">Vines & Flowers ğŸŒ¿</option>
                    </optgroup>
                </select>
            </div>
            <div class="setting-group">
                <label>Background Pattern:</label>
                 <select id="bg-select" onchange="changeBackground(this.value)">
                    <option value="none">None (White)</option>
                    <option value="hearts">Hearts</option>
                    <option value="stripes">Stripes</option>
                    <option value="flowers">Flowers</option>
                    <option value="custom">Custom...</option>
                </select>
                <input type="file" id="custom-bg-input" accept="image/*" style="display:none" onchange="handleCustomBackground(event)">
            </div>
            <div class="setting-group">
                <label>Paper Size:</label>
                <select id="paper-size" onchange="changePaperSize(this.value)">
                    <option value="4x6">4" x 6" (Recommended)</option>
                    <option value="hagaki">100mm x 148mm (Official)</option>
                    <option value="letter">8.5" x 11" (Letter)</option>
                </select>
            </div>
        </div>
    </div>
    
    <!-- 2. Project Buttons -->
    <div class="control-section">
        <div class="project-buttons">
            <button class="btn-project" onclick="saveProject()">
                <span class="emoji-icon">ğŸ’¾</span> Save Project
            </button>
            <button class="btn-project" onclick="document.getElementById('load-project-input').click()">
                <span class="emoji-icon">ğŸ“‚</span> Load Project
            </button>
            <input type="file" id="load-project-input" accept=".json" style="display:none" onchange="loadProject(event)">
        </div>
    </div>
    
    <!-- 3. Layout, Upload, Actions -->
    <div class="control-section">
        <div class="mode-selector">
            <button onclick="setMode('single')" id="btn-single">1 Photo (1x16)</button>
            <button onclick="setMode('quad')" id="btn-quad">4 Photos (2x2 Grid)</button>
            <button onclick="setMode('unique')" id="btn-unique">16 Unique Photos</button>
        </div>
        
        <!-- The Upload Grid -->
        <div class="upload-area" id="upload-inputs" data-mode="quad"></div>

        <div class="action-bar">
            <!-- Left -->
            <button class="help-btn" onclick="toggleHelp()" title="Open Guide">?</button>
            
            <!-- Center Toggles -->
            <div class="toggles">
                <label class="toggle-label">
                    <input type="checkbox" id="toggle-overlay" onchange="toggleOverlay()">
                    Show Kiss Cut
                </label>

                <label class="toggle-label" title="Simulates faded, old ink">
                    <input type="checkbox" id="toggle-weathered" onchange="toggleWeathered()">
                    Fade
                </label>
                
                <label class="toggle-label" title="Simulates CRT scanlines">
                    <input type="checkbox" id="toggle-crt" onchange="toggleCRT()">
                    CRT Effect
                </label>
            </div>
            
            <!-- Right Actions -->
            <div class="actions-right">
                <input type="file" id="bulk-input" multiple accept="image/png, image/jpeg, image/gif, image/webp, video/webm" style="display:none" onchange="handleBulkUpload(event)">
                
                <button class="btn-purple" onclick="importFromSnapStation()">
                    <span class="emoji-icon">ğŸ“·</span> Import Snaps
                </button>

                <button class="btn-purple" onclick="document.getElementById('bulk-input').click()">
                    <span class="emoji-icon">ğŸ“¤</span> Upload
                </button>

                <div class="save-group">
                    <select id="export-format">
                        <option value="png">PNG</option>
                        <option value="jpg">JPG</option>
                        <option value="pdf">PDF</option>
                        <option value="gif">GIF</option>
                    </select>
                    <div class="save-separator"></div>
                    <button class="btn-green" onclick="saveOutput()">Save</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="paper">
    <div id="background-layer"></div>
    <div id="sticker-grid"></div>
    <div id="dither-overlay"></div>
    <div id="crt-overlay"></div>
    <div id="stamp-layer"></div>
</div>

<button class="btn-project" onclick="downloadCuttingTemplate()" style="display:block; width:100%; max-width:800px; margin:20px auto; justify-content:center; background: var(--light-blue); color: var(--text);">
    Download Cutting Template (SVG)
</button>

<div class="stamp-selector">
    <label>Add Stamp:</label>
    <div class="stamp-list">
        <!-- New Requested Emoji List - Consolidated and Cleaned -->
        <button class="btn-stamp-add" onclick="addStamp('âš¡')">âš¡</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ”¥')">ğŸ”¥</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’§')">ğŸ’§</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒ±')">ğŸŒ±</button>
        <button class="btn-stamp-add" onclick="addStamp('â„ï¸')">â„ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸª¨')">ğŸª¨</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ‰')">ğŸ‰</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ§ª')">ğŸ§ª</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒ€')">ğŸŒ€</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒ©ï¸')">ğŸŒ©ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ®')">ğŸ®</button>
        <button class="btn-stamp-add" onclick="addStamp('â­')">â­</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’')">ğŸ’</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ§¢')">ğŸ§¢</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ”')">ğŸ”</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ‹ï¸')">ğŸ‹ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('âš”ï¸')">âš”ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ“')">ğŸ“</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ“¸')">ğŸ“¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¤³')">ğŸ¤³</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸï¸')">ğŸï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ“·')">ğŸ“·</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ–¼ï¸')">ğŸ–¼ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒ¿')">ğŸŒ¿</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒ‹')">ğŸŒ‹</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸœï¸')">ğŸœï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒŠ')">ğŸŒŠ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒŒ')">ğŸŒŒ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸªµ')">ğŸªµ</button>
        <button class="btn-stamp-add" onclick="addStamp('âœ¨')">âœ¨</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’')">ğŸ’</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ')">ğŸ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ””')">ğŸ””</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’«')">ğŸ’«</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ˜²')">ğŸ˜²</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’¤')">ğŸ’¤</button>
        <button class="btn-stamp-add" onclick="addStamp('â­')">â­</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ“')">ğŸ“</button>
        <button class="btn-stamp-add" onclick="addStamp('â•')">â•</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¯')">ğŸ¯</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ‘€')">ğŸ‘€</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸš™')">ğŸš™</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ›¤ï¸')">ğŸ›¤ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ›°ï¸')">ğŸ›°ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ“¡')">ğŸ“¡</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ”')">ğŸ”</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸªˆ')">ğŸªˆ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¶')">ğŸ¶</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸµ')">ğŸµ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’œ')">ğŸ’œ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’™')">ğŸ’™</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’š')">ğŸ’š</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’›')">ğŸ’›</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¤')">ğŸ¤</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¤')">ğŸ¤</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ©·')">ğŸ©·</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ©µ')">ğŸ©µ</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ©¶')">ğŸ©¶</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ˜²')">ğŸ˜²</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¥º')">ğŸ¥º</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ˜³')">ğŸ˜³</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¥°')">ğŸ¥°</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ˜»')">ğŸ˜»</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¤—')">ğŸ¤—</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ˜‡')">ğŸ˜‡</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸŒ¸')">ğŸŒ¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ¾')">ğŸ¾</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ€')">ğŸ€</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ±')">ğŸ±</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ§¸')">ğŸ§¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ‘»')">ğŸ‘»</button>
        <button class="btn-stamp-add" onclick="addStamp('â˜ ï¸')">â˜ ï¸</button>
        <button class="btn-stamp-add" onclick="addStamp('ğŸ’€')">ğŸ’€</button>
        
        <!-- Custom Input replacing "More..." button -->
        <input type="text" placeholder="Type or paste emoji" class="custom-stamp-input" onkeypress="if(event.key === 'Enter'){ window.addStamp(this.value); this.value=''; }">
    </div>
    
    <div class="text-stamp-controls">
        <input type="text" id="text-stamp-input" placeholder="Type text..." class="text-input">
        <select id="text-font-select" style="flex:1;">
            <option value="'Press Start 2P', cursive">8-Bit</option>
            <option value="'Bangers', cursive">Comic</option>
            <option value="'Permanent Marker', cursive">Marker</option>
            <option value="'VT323', monospace">Terminal</option>
            <option value="'Pacifico', cursive">Script</option>
        </select>
        <input type="color" id="text-color-input" value="#000000" class="color-input">
        <button class="btn-green" style="border-radius:6px; color:white;" onclick="addTextStampFromInput()">Add</button>
    </div>
</div>

<script>
    (function() {
        // Global variables
        window.groupImages = [];
        window.cropperInstances = [];
        window.cellGroups = new Array(16).fill(0);
        let activeStamp = null;

        // State
        window.currentMode = 'quad'; 
        let isSyncing = false; 
        let syncFrameId = null;
        let interactionMode = null;
        let startX, startY, startLeft, startTop, startRotation, startFontSize, centerX, centerY, dragSrcIndex = null;

        // DOM Elements
        const gridEl = document.getElementById('sticker-grid');
        const uploadContainer = document.getElementById('upload-inputs');
        const bgLayer = document.getElementById('background-layer');
        const stampLayer = document.getElementById('stamp-layer');
        const paperElement = document.getElementById('paper');
        
        // Cache cell selector
        const allCells = () => document.querySelectorAll('.cell');

        const bgPatterns = {
            hearts: `data:image/svg+xml;charset=utf-8,<svg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23FFB6C1'/><text x='0' y='15' font-size='15'>â¤ï¸</text><text x='20' y='35' font-size='15'>â¤ï¸</text><text x='20' y='15' font-size='15'>ğŸ«§</text><text x='0' y='35' font-size='15'>ğŸ«§</text></svg>`,
            stripes: `data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='40' height='40' fill='%23FFCB05'/%3E%3Cpath d='M0 40 L40 0 L20 0 L0 20 Z M40 40 L40 20 L20 40 Z' fill='black'/%3E%3C/svg%3E`,
            flowers: `data:image/svg+xml;charset=utf-8,<svg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23C1FFB6'/><text x='0' y='15' font-size='15'>ğŸŒ¿</text><text x='20' y='35' font-size='15'>ğŸŒ¿</text><text x='20' y='15' font-size='15'>ğŸŒ¸</text><text x='0' y='35' font-size='15'>ğŸŒ¸</text></svg>`
        };

        const stickerW = 26.6, stickerH = 20;
        const innerX = 1.25, innerY = 0.833;
        const innerW = 24.1, innerH = 17.5;
        const radius = 2.75;
        
        const overlayPath = `M ${innerX+radius} ${innerY} L ${innerX+innerW-radius} ${innerY} Q ${innerX+innerW} ${innerY} ${innerX+innerW} ${innerY+radius} L ${innerX+innerW} ${innerY+innerH-radius} Q ${innerX+innerW} ${innerY+innerH} ${innerX+innerW-radius} ${innerY+innerH} L ${innerX+radius} ${innerY+innerH} Q ${innerX} ${innerY+innerH} ${innerX} ${innerY+innerH-radius} L ${innerX} ${innerY+radius} Q ${innerX} ${innerY} ${innerX+radius} ${innerY} Z`;

        function init() {
            gridEl.innerHTML = '';
            window.cropperInstances = new Array(16).fill(null);
            
            for(let i=0; i<16; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${i}`;
                
                // Double Click Reset
                cell.addEventListener('dblclick', function() {
                    const idx = parseInt(this.id.split('-')[1]);
                    if (window.cropperInstances[idx]) {
                        window.cropperInstances[idx].reset();
                    }
                });
                
                const imgContainer = document.createElement('div');
                imgContainer.className = 'img-container';
                const img = document.createElement('img');
                img.className = 'source-image'; 
                img.style.display = 'none'; 
                imgContainer.appendChild(img);
                cell.appendChild(imgContainer);

                const crtOverlay = document.createElement('div');
                crtOverlay.className = 'cell-effect-layer crt-cell-overlay';
                cell.appendChild(crtOverlay);

                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                overlay.innerHTML = `<svg viewBox="0 0 26.6 20"><path d="${overlayPath}" /></svg>`;
                cell.appendChild(overlay);

                gridEl.appendChild(cell);
            }

            window.setMode('quad');

            window.addEventListener('mousedown', handleGlobalMouseDown);
            window.addEventListener('mousemove', handleGlobalMouseMove);
            window.addEventListener('mouseup', handleGlobalMouseUp);
            window.addEventListener('touchmove', handleGlobalMouseMove, {passive: false});
            window.addEventListener('touchend', handleGlobalMouseUp);
        }

        // --- KONAMI CODE ---
        const konamiSeq = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a', 'Enter'];
        let konamiIndex = 0;

        document.addEventListener('keydown', (e) => {
            if (e.key === konamiSeq[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiSeq.length) {
                    unlock1UpTheme();
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });

        window.unlock1UpTheme = function() {
            const opt = document.getElementById('theme-1up-option');
            if(opt) {
                opt.removeAttribute('hidden');
                opt.removeAttribute('disabled');
                const select = document.getElementById('theme-select');
                select.value = '1-up';
                changeTheme('1-up');
                showToast('ğŸ„ 1-UP Theme Unlocked!');
            }
        }

        // --- THEME & WALLPAPER LOGIC ---
        const emojiConfigs = {
            hearts: ['ğŸ’–', 'ğŸ«§', 'ğŸ’˜', 'ğŸ§¼'],
            vines: ['ğŸŒ¿', 'ğŸŒ¸', 'ğŸƒ', 'ğŸŒ»'],
            '1-up': ['ğŸ„', 'â­', 'ğŸª™', 'ğŸ¢', 'â“']
        };

        const emojiWallpaper = document.getElementById('emojiWallpaper');

        function generateEmojiWallpaper(theme) {
            emojiWallpaper.innerHTML = '';
            if (!emojiConfigs[theme]) {
                emojiWallpaper.classList.remove('active');
                return;
            }

            const emojis = emojiConfigs[theme];
            for (let i = 0; i < 80; i++) {
                const span = document.createElement('span');
                span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                span.style.left = `${Math.random() * 100}%`;
                span.style.top = `${Math.random() * 100}%`;
                span.style.animationDelay = `${Math.random() * 8}s`;
                span.style.fontSize = `${Math.random() * 20 + 16}px`;
                emojiWallpaper.appendChild(span);
            }
            emojiWallpaper.classList.add('active');
        }

        window.changeTheme = function(themeValue) {
            document.body.setAttribute('data-theme', themeValue);
            generateEmojiWallpaper(themeValue);
        }

        // --- VECTOR SVG EXPORT ---
        window.downloadCuttingTemplate = function() {
            const paperSelect = document.getElementById('paper-size').value;
            let pW_mm = 152.4, pH_mm = 101.6, scalingFactor = 1.0;

            if (paperSelect === 'hagaki') {
                pW_mm = 148; pH_mm = 100;
            } else if (paperSelect === 'letter') {
                pW_mm = 279.4; pH_mm = 215.9; scalingFactor = 2.2;
            }

            const cellW = 26.6, cellH = 20, gap = 1;
            const effectiveCellW = cellW * scalingFactor;
            const effectiveCellH = cellH * scalingFactor;
            const effectiveGap = gap * scalingFactor;

            const gridTotalW = (effectiveCellW * 4) + (effectiveGap * 3);
            const gridTotalH = (effectiveCellH * 4) + (effectiveGap * 3);

            const marginLeft = (pW_mm - gridTotalW) / 2;
            const marginTop = (pH_mm - gridTotalH) / 2;

            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${pW_mm}mm" height="${pH_mm}mm" viewBox="0 0 ${pW_mm} ${pH_mm}">`;
            svgContent += `<rect x="0" y="0" width="${pW_mm}" height="${pH_mm}" fill="none" stroke="red" stroke-width="0.1" />`;
            
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    const x = marginLeft + (c * (effectiveCellW + effectiveGap));
                    const y = marginTop + (r * (effectiveCellH + effectiveGap));
                    svgContent += `<g transform="translate(${x}, ${y}) scale(${scalingFactor})">`;
                    svgContent += `<path d="${overlayPath}" fill="none" stroke="black" stroke-width="${0.1/scalingFactor}" />`;
                    svgContent += `</g>`;
                }
            }
            svgContent += `</svg>`;

            const blob = new Blob([svgContent], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'cutting-template.svg';
            link.click();
            URL.revokeObjectURL(url);
        }

        // --- PASTE FUNCTION ---
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => { toast.classList.remove('visible'); }, 4000);
        }

        // Global Paste Listener
        window.addEventListener('paste', function(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            const imageBlobs = [];
            
            for (let index in items) {
                const item = items[index];
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const blob = item.getAsFile();
                    imageBlobs.push(blob);
                }
            }

            if (imageBlobs.length > 0) {
                e.preventDefault(); 
                processPastedImages(imageBlobs);
                showToast(`Pasted ${imageBlobs.length} image(s)`);
            }
        });

        function processPastedImages(imageBlobs) {
            if (imageBlobs.length === 0) return;
            let targetMode;
            if (imageBlobs.length === 1) targetMode = 'single';
            else if (imageBlobs.length <= 4) targetMode = 'quad';
            else targetMode = 'unique';
            
            window.setMode(targetMode);
            setTimeout(() => {
                const numSlots = window.groupImages.length;
                imageBlobs.slice(0, numSlots).forEach((blob, index) => {
                    if (window.groupImages[index] && window.groupImages[index].url) {
                        URL.revokeObjectURL(window.groupImages[index].url);
                    }
                    window.groupImages[index] = { 
                        url: URL.createObjectURL(blob), 
                        canvasData: null, 
                        cropBoxData: null 
                    };
                });
                refreshGrid();
            }, 100);
        }

        // --- IMPORT FROM SNAP STATION ---
        window.importFromSnapStation = function() {
            try {
                const data = localStorage.getItem('snapstation-export');
                if (!data) {
                    showToast('No snaps queued. Select snaps in Snap Station and click "Send to Stickers".');
                    return;
                }
                
                let parsed;
                try { parsed = JSON.parse(data); } catch (e) {
                    showToast('Invalid data. Try again.');
                    localStorage.removeItem('snapstation-export');
                    return;
                }
                
                const images = parsed.images;
                
                if (!images || images.length === 0) {
                    showToast('No images found.');
                    localStorage.removeItem('snapstation-export');
                    return;
                }
                
                // Set appropriate mode
                if (images.length === 1) window.setMode('single');
                else if (images.length <= 4) window.setMode('quad');
                else window.setMode('unique');
                
                // Wait for mode switch to complete, then load images
                setTimeout(() => {
                    const numSlots = window.groupImages.length;
                    images.slice(0, numSlots).forEach((dataUrl, index) => {
                        // Clean up old URL if it's a blob URL
                        if (window.groupImages[index] && window.groupImages[index].url && window.groupImages[index].url.startsWith('blob:')) {
                            URL.revokeObjectURL(window.groupImages[index].url);
                        }
                        // Data URLs work directly - no need to convert
                        window.groupImages[index] = { 
                            url: dataUrl,  
                            canvasData: null, 
                            cropBoxData: null 
                        };
                    });
                    refreshGrid();
                    
                    const imported = Math.min(images.length, numSlots);
                    showToast(`Imported ${imported} snap${imported !== 1 ? 's' : ''}`);
                    
                    // Clear the export data after successful import
                    localStorage.removeItem('snapstation-export');
                }, 150);
            } catch(e) {
                console.error("Import failed:", e);
                showToast("Failed to import snaps.");
            }
        }

        // Auto-check for pending imports
        function checkForPendingImports() {
            try {
                const data = localStorage.getItem('snapstation-export');
                if (data) {
                    try {
                        const parsed = JSON.parse(data);
                        const count = parsed.images?.length || 0;
                        if (count > 0) {
                            showToast(`${count} snap${count !== 1 ? 's' : ''} ready to import. Click "Import Snaps".`);
                            return true;
                        }
                    } catch (e) {}
                }
            } catch(e) {}
            return false;
        }

        // Check on load
        setTimeout(checkForPendingImports, 500);

        // Listen for storage changes from other tabs/frames
        window.addEventListener('storage', (e) => {
            if (e.key === 'snapstation-export' && e.newValue) {
                checkForPendingImports();
            }
        });

        // Poll periodically (storage event doesn't fire in same window/frame)
        setInterval(() => {
            const data = localStorage.getItem('snapstation-export');
            if (data) checkForPendingImports();
        }, 2000);

        window.toggleHelp = function() {
            const modal = document.getElementById('help-modal');
            modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
        }

        window.changePaperSize = function(size) {
            const root = document.documentElement;
            if(size === '4x6') {
                root.style.setProperty('--paper-width', '152.4mm'); root.style.setProperty('--paper-height', '101.6mm');
                root.style.setProperty('--cell-width', '26.6mm'); root.style.setProperty('--cell-height', '20mm');
                root.style.setProperty('--gap', '1mm');
            } else if(size === 'hagaki') {
                root.style.setProperty('--paper-width', '148mm'); root.style.setProperty('--paper-height', '100mm');
                root.style.setProperty('--cell-width', '26.6mm'); root.style.setProperty('--cell-height', '20mm');
                root.style.setProperty('--gap', '1mm');
            } else {
                 root.style.setProperty('--paper-width', '279.4mm'); root.style.setProperty('--paper-height', '215.9mm');
                 root.style.setProperty('--cell-width', '58.52mm'); root.style.setProperty('--cell-height', '44mm');
                 root.style.setProperty('--gap', '2.2mm');
            }
        }

        window.toggleWeathered = function() {
            const show = document.getElementById('toggle-weathered').checked;
            allCells().forEach(cell => cell.classList.toggle('weathered-active', show));
        }

        window.toggleCRT = function() {
            const show = document.getElementById('toggle-crt').checked;
            allCells().forEach(cell => cell.classList.toggle('crt-active', show));
        }
        
        window.clearImage = function(index) {
             if (window.groupImages[index] && window.groupImages[index].url) { URL.revokeObjectURL(window.groupImages[index].url); }
            window.groupImages[index] = null; 
            const input = document.querySelector(`.file-input-wrapper[data-index="${index}"] input[type=file]`);
            if(input) input.value = '';
            refreshGrid();
        }

        // --- Custom Background Handling (Fixed Memory Leak) ---
        window.handleCustomBackground = function(event) {
            const bgLayer = document.getElementById('background-layer');
            const file = event.target.files[0]; if(!file) return;
            // Revoke old URL if stored
            if (bgLayer.dataset.customBgUrl) {
                URL.revokeObjectURL(bgLayer.dataset.customBgUrl);
            }
            const url = URL.createObjectURL(file);
            bgLayer.dataset.customBgUrl = url;
            bgLayer.style.backgroundImage = `url("${url}")`;
        }

        // --- Stamp Logic ---
        window.addStamp = function(emoji, x, y, size, rotation) {
            createStamp(emoji, x, y, size, rotation, false);
        }

        window.addTextStampFromInput = function() {
            const text = document.getElementById('text-stamp-input').value;
            if(!text) return;
            const font = document.getElementById('text-font-select').value;
            const color = document.getElementById('text-color-input').value;
            createStamp(text, undefined, undefined, undefined, undefined, true, font, color);
            document.getElementById('text-stamp-input').value = '';
        }

        function createStamp(contentStr, x, y, size, rotation, isText=false, font='', color='') {
            const wrapper = document.createElement('div');
            wrapper.className = 'stamp-wrapper';
            wrapper.dataset.isText = isText;
            if(isText) { wrapper.dataset.font = font; wrapper.dataset.color = color; }
            
            const paper = document.getElementById('paper');
            const initialX = x !== undefined ? x : (paper.offsetWidth / 2);
            const initialY = y !== undefined ? y : (paper.offsetHeight / 2);
            const initialSize = size !== undefined ? size : (isText ? '2rem' : '3rem');
            const initialRot = rotation !== undefined ? rotation : 0;

            wrapper.style.left = initialX + 'px';
            wrapper.style.top = initialY + 'px';
            wrapper.style.transform = `translate(-50%, -50%) rotate(${initialRot}deg)`;

            const content = document.createElement('div');
            content.className = 'stamp-content';
            content.innerText = contentStr;
            content.style.fontSize = initialSize;
            
            if(isText) {
                content.style.fontFamily = font;
                content.style.color = color;
                content.style.whiteSpace = 'nowrap';
                content.style.textShadow = '2px 2px 0px rgba(0,0,0,0.5)';
            }
            wrapper.appendChild(content);

            const controls = document.createElement('div');
            controls.className = 'stamp-controls';
            
            const createHandle = (cls, html, title) => {
                const el = document.createElement('div'); el.className = `handle ${cls}`; el.innerHTML = html; el.title = title;
                return el;
            };
            controls.appendChild(createHandle('handle-del', 'Ã—', 'Delete'));
            controls.appendChild(createHandle('handle-rot', 'â†»', 'Rotate'));
            controls.appendChild(createHandle('handle-sz', 'â†”', 'Resize'));

            wrapper.appendChild(controls);
            stampLayer.appendChild(wrapper);

            const handleStart = (e, mode) => { e.stopPropagation(); selectStamp(wrapper); startInteraction(e, wrapper, mode); };

            wrapper.addEventListener('mousedown', (e) => {
                e.stopPropagation(); selectStamp(wrapper);
                if (e.target.classList.contains('handle-del')) { wrapper.remove(); activeStamp = null; }
                else if (e.target.classList.contains('handle-rot')) { startInteraction(e, wrapper, 'rotate'); }
                else if (e.target.classList.contains('handle-sz')) { startInteraction(e, wrapper, 'resize'); }
                else { startInteraction(e, wrapper, 'drag'); }
            });
            
            wrapper.addEventListener('touchstart', (e) => {
                e.stopPropagation(); selectStamp(wrapper);
                const touch = e.touches[0];
                const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY, preventDefault: ()=>e.preventDefault() };
                if (e.target.classList.contains('handle-del')) { wrapper.remove(); activeStamp = null; }
                else if (e.target.classList.contains('handle-rot')) { startInteraction(fakeEvent, wrapper, 'rotate'); }
                else if (e.target.classList.contains('handle-sz')) { startInteraction(fakeEvent, wrapper, 'resize'); }
                else { startInteraction(fakeEvent, wrapper, 'drag'); }
            }, {passive: false});
        }

        function selectStamp(stamp) {
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected'));
            stamp.classList.add('selected'); activeStamp = stamp;
        }

        function deselectAll() {
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected'));
            activeStamp = null;
        }

        function startInteraction(e, wrapper, mode) {
            e.preventDefault();
            interactionMode = mode;
            startX = e.clientX; startY = e.clientY;
            startLeft = parseFloat(wrapper.style.left); startTop = parseFloat(wrapper.style.top);
            
            const st = window.getComputedStyle(wrapper);
            const tr = st.getPropertyValue("transform");
            let angle = 0;
            if (tr && tr !== 'none') {
                const values = tr.split('(')[1].split(')')[0].split(',');
                angle = Math.round(Math.atan2(values[1], values[0]) * (180/Math.PI));
            }
            startRotation = angle;
            const rect = wrapper.getBoundingClientRect();
            centerX = rect.left + rect.width / 2; centerY = rect.top + rect.height / 2;
            startFontSize = parseFloat(window.getComputedStyle(wrapper.querySelector('.stamp-content')).fontSize);
        }

        function handleGlobalMouseDown(e) {
            if (e.target.id === 'stamp-layer' || e.target.id === 'background-layer') deselectAll();
        }

        function handleGlobalMouseMove(e) {
            if (!activeStamp || !interactionMode) return;
            e.preventDefault();
            const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

            if (interactionMode === 'drag') {
                const dx = clientX - startX; const dy = clientY - startY;
                activeStamp.style.left = (startLeft + dx) + 'px';
                activeStamp.style.top = (startTop + dy) + 'px';
            } else if (interactionMode === 'resize') {
                const distStart = Math.hypot(startX - centerX, startY - centerY);
                const distNow = Math.hypot(clientX - centerX, clientY - centerY);
                const scale = distNow / distStart;
                const newSize = Math.max(10, startFontSize * scale); 
                activeStamp.querySelector('.stamp-content').style.fontSize = newSize + 'px';
            } else if (interactionMode === 'rotate') {
                const angleStart = Math.atan2(startY - centerY, startX - centerX);
                const angleNow = Math.atan2(clientY - centerY, clientX - centerX);
                const angleChange = (angleNow - angleStart) * (180 / Math.PI);
                activeStamp.style.transform = `translate(-50%, -50%) rotate(${startRotation + angleChange}deg)`;
            }
        }

        function handleGlobalMouseUp() { interactionMode = null; }

        function refreshGrid() {
            window.cellGroups.fill(-1);
            if (window.currentMode === 'single') { window.cellGroups.fill(0); } 
            else if (window.currentMode === 'unique') { for(let i=0; i<16; i++) window.cellGroups[i] = i; } 
            else if (window.currentMode === 'quad') {
                const mapping = [[0, 1, 4, 5], [2, 3, 6, 7], [8, 9, 12, 13], [10, 11, 14, 15]];
                mapping.forEach((indices, groupIdx) => { indices.forEach(cellIdx => window.cellGroups[cellIdx] = groupIdx); });
            }

            for(let i=0; i<16; i++) {
                let imgData = null;
                let groupIdx = -1;
                if (window.currentMode === 'single') { imgData = window.groupImages[0]; groupIdx = 0; }
                else if (window.currentMode === 'unique') { imgData = window.groupImages[i]; groupIdx = i; }
                else { groupIdx = window.cellGroups[i]; imgData = window.groupImages[groupIdx]; }
                updateCell(i, imgData, groupIdx);
            }
            refreshButtonPreviews();
        }

        function updateCell(index, imgData, groupIdx) {
            const cell = document.getElementById(`cell-${index}`);
            const img = cell.querySelector('.img-container img.source-image');
            const currentUrl = img.getAttribute('src');
            const newUrl = (imgData && imgData.url) ? imgData.url : '';
            if (currentUrl === newUrl && window.cropperInstances[index]) return;
            if (window.cropperInstances[index]) { window.cropperInstances[index].destroy(); window.cropperInstances[index] = null; }

            if (newUrl) {
                img.src = newUrl; img.style.display = 'block';
                const cropper = new Cropper(img, {
                    aspectRatio: stickerW / stickerH, viewMode: 1, dragMode: 'move', autoCropArea: 1, restore: false, guides: false, center: false, highlight: false, cropBoxMovable: false, cropBoxResizable: false, toggleDragModeOnDblclick: false, minContainerWidth: 100, minContainerHeight: 75, checkCrossOrigin: false, modal: false, background: false,
                    ready: function() {
                        this.cropper.isCustomReady = true;
                        if (imgData.canvasData) try { this.cropper.setCanvasData(imgData.canvasData); } catch(e) {}
                        if (imgData.cropBoxData) try { this.cropper.setCropBoxData(imgData.cropBoxData); } catch(e) {}
                    },
                    crop: function(event) {
                        if (!isSyncing && this.cropper.isCustomReady) {
                            if (syncFrameId) cancelAnimationFrame(syncFrameId);
                            syncFrameId = requestAnimationFrame(() => {
                                try {
                                    const canvasData = this.cropper.getCanvasData();
                                    const cropBoxData = this.cropper.getCropBoxData();
                                    if (window.groupImages[groupIdx]) { window.groupImages[groupIdx].canvasData = canvasData; window.groupImages[groupIdx].cropBoxData = cropBoxData; }
                                    syncCrops(index, groupIdx, canvasData, cropBoxData);
                                } catch(e) { isSyncing=false; }
                            });
                        }
                    }
                });
                window.cropperInstances[index] = cropper; cropper.isCustomReady = false;
            } else { img.style.display = 'none'; img.src = ''; }
        }
        
        function syncCrops(sourceCellIndex, groupIdx, canvasData, cropBoxData) {
            isSyncing = true;
            for (let i = 0; i < 16; i++) {
                const target = window.cropperInstances[i];
                if (i !== sourceCellIndex && window.cellGroups[i] === groupIdx && target && target.isCustomReady) {
                    try { target.setCanvasData(canvasData); target.setCropBoxData(cropBoxData); } catch(e) {}
                }
            }
            isSyncing = false;
        }

        window.resetCrop = function(groupIdx) {
            isSyncing = true;
            if(window.groupImages[groupIdx]) { 
                window.groupImages[groupIdx].canvasData = null; 
                window.groupImages[groupIdx].cropBoxData = null; 
            }
            for (let i = 0; i < 16; i++) { 
                if (window.cellGroups[i] === groupIdx && window.cropperInstances[i]) {
                    window.cropperInstances[i].reset(); 
                }
            }
            isSyncing = false;
        }

        function refreshButtonPreviews() {
            const buttons = document.querySelectorAll('.btn-upload');
            buttons.forEach((btn, idx) => {
                let existingPreview = btn.parentElement.querySelector('.btn-preview');
                if (!existingPreview) { existingPreview = document.createElement('img'); existingPreview.className = 'btn-preview'; btn.parentElement.prepend(existingPreview); }
                if (window.groupImages[idx] && window.groupImages[idx].url) { existingPreview.src = window.groupImages[idx].url; existingPreview.style.display = 'block'; } 
                else { existingPreview.style.display = 'none'; }
            });
        }

        window.setMode = function(mode) {
            window.currentMode = mode;
            document.querySelectorAll('.mode-selector button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            
            // Set dynamic grid attribute
            document.getElementById('upload-inputs').setAttribute('data-mode', mode);
            uploadContainer.innerHTML = '';
            
            let inputCount = (mode === 'quad') ? 4 : (mode === 'unique' ? 16 : 1);
            
            const oldImages = [...window.groupImages];
            window.groupImages = new Array(inputCount).fill(null);
            for(let i=0; i<Math.min(oldImages.length, inputCount); i++) { window.groupImages[i] = oldImages[i]; }
            
            for(let i=0; i<inputCount; i++) {
                const wrapper = document.createElement('div'); wrapper.className = 'file-input-wrapper'; wrapper.draggable = true; wrapper.dataset.index = i;
                wrapper.addEventListener('dragstart', handleDragStart); wrapper.addEventListener('dragover', handleDragOver); wrapper.addEventListener('dragleave', handleDragLeave); wrapper.addEventListener('drop', handleDrop); wrapper.addEventListener('dragend', handleDragEnd);
                
                const btn = document.createElement('div'); btn.className = 'btn-upload';
                
                // --- X BUTTON (DELETE) ---
                const delBtn = document.createElement('div'); 
                delBtn.className = 'btn-delete'; 
                delBtn.innerHTML = '<i class="fas fa-times"></i>'; 
                delBtn.title = 'Remove Image';
                delBtn.onclick = (e) => { 
                    e.stopPropagation(); 
                    window.clearImage(i); 
                };
                
                const refreshIconBox = document.createElement('div');
                refreshIconBox.className = 'refresh-icon-box';
                refreshIconBox.innerHTML = '<i class="fas fa-sync"></i>'; 
                
                const labelText = document.createElement('span'); 
                if (mode === 'single') labelText.innerHTML = `Upload Files<br><small>(JPG, PNG, GIF)</small>`;
                else if (mode === 'quad') labelText.innerHTML = `Upload Group ${i+1}<br><small>(JPG, PNG, GIF)</small>`;
                else labelText.innerHTML = `Image ${i+1}`;
                
                btn.appendChild(refreshIconBox);
                btn.appendChild(labelText); 
                btn.appendChild(delBtn); 
                
                const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/png, image/jpeg, image/gif, image/webp, video/webm';
                input.onchange = (e) => window.handleUpload(e, i);
                wrapper.appendChild(btn); wrapper.appendChild(input); uploadContainer.appendChild(wrapper);
            }
            refreshGrid();
        }

        window.handleUpload = function(event, inputIndex) {
            const file = event.target.files[0]; if(!file) return;
            if (window.groupImages[inputIndex] && window.groupImages[inputIndex].url) URL.revokeObjectURL(window.groupImages[inputIndex].url);
            window.groupImages[inputIndex] = { url: URL.createObjectURL(file), canvasData: null, cropBoxData: null };
            refreshGrid();
        }

        window.handleBulkUpload = function(event) {
            const files = Array.from(event.target.files); if(files.length === 0) return;
            if (files.length === 1) window.setMode('single'); else if (files.length <= 4) window.setMode('quad'); else window.setMode('unique');
            setTimeout(() => {
                files.slice(0, 16).forEach((file, index) => {
                   if (index < window.groupImages.length) {
                       if (window.groupImages[index] && window.groupImages[index].url) URL.revokeObjectURL(window.groupImages[index].url);
                       window.groupImages[index] = { url: URL.createObjectURL(file), canvasData: null, cropBoxData: null };
                   }
                });
                refreshGrid();
            }, 0);
        }

        function handleDragStart(e) { this.classList.add('dragging'); dragSrcIndex = parseInt(this.dataset.index); e.dataTransfer.effectAllowed = 'move'; }
        function handleDragOver(e) { if (e.preventDefault) e.preventDefault(); this.classList.add('drag-over'); e.dataTransfer.dropEffect = 'move'; return false; }
        function handleDragLeave(e) { this.classList.remove('drag-over'); }
        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation(); this.classList.remove('drag-over');
            const dragDestIndex = parseInt(this.dataset.index);
            if (dragSrcIndex !== null && dragSrcIndex !== dragDestIndex) {
                const temp = window.groupImages[dragSrcIndex]; window.groupImages[dragSrcIndex] = window.groupImages[dragDestIndex]; window.groupImages[dragDestIndex] = temp;
                refreshGrid();
            }
            return false;
        }
        function handleDragEnd(e) { this.classList.remove('dragging'); document.querySelectorAll('.file-input-wrapper').forEach(col => { col.classList.remove('drag-over'); }); }

        window.toggleOverlay = function() {
            const show = document.getElementById('toggle-overlay').checked;
            document.querySelectorAll('.overlay').forEach(o => { show ? o.classList.add('visible') : o.classList.remove('visible'); });
        }
        
        window.changeBackground = function(value) {
            if (value === 'custom') { document.getElementById('custom-bg-input').click(); }
            else if (value === 'none') { bgLayer.style.backgroundImage = 'none'; }
            else if (bgPatterns[value]) { bgLayer.style.backgroundImage = `url("${bgPatterns[value]}")`; }
        }

        function urlToBase64(url) {
            return fetch(url).then(res => res.blob()).then(blob => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            });
        }

        window.saveProject = async function() {
            const loadingOverlay = document.getElementById('loading-overlay');
            try {
                loadingOverlay.style.display = 'flex';
                const stamps = [];
                document.querySelectorAll('#stamp-layer .stamp-wrapper').forEach(el => {
                    const st = window.getComputedStyle(el); const tr = st.getPropertyValue("transform");
                    let angle = 0; if (tr && tr !== 'none') { const values = tr.split('(')[1].split(')')[0].split(','); angle = Math.round(Math.atan2(values[1], values[0]) * (180/Math.PI)); }
                    const content = el.querySelector('.stamp-content');
                    stamps.push({
                        text: content.innerText, left: parseFloat(el.style.left), top: parseFloat(el.style.top),
                        size: content.style.fontSize, rotation: angle,
                        isText: el.dataset.isText === 'true', font: el.dataset.font, color: el.dataset.color
                    });
                });

                const savedImages = [];
                for (let i = 0; i < window.groupImages.length; i++) {
                    if (window.groupImages[i] && window.groupImages[i].url) {
                        try { const b64 = await urlToBase64(window.groupImages[i].url); savedImages[i] = { b64: b64, canvasData: window.groupImages[i].canvasData, cropBoxData: window.groupImages[i].cropBoxData }; } catch (e) { savedImages[i] = null; }
                    } else { savedImages[i] = null; }
                }
                const projectData = {
                    theme: document.body.getAttribute('data-theme'), // Use data attribute
                    bgValue: document.getElementById('bg-select').value,
                    paperSize: document.getElementById('paper-size').value,
                    mode: window.currentMode, images: savedImages, stamps: stamps
                };
                const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'snap-station-project.json';
                a.click();
                URL.revokeObjectURL(url);
                showToast('Project saved successfully!');
            } catch(err) {
                console.error('Project save error:', err);
                showToast('Failed to save project - file may be too large');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }

        window.loadProject = function(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Validate project structure
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid project format');
                    }

                    if (data.theme) { document.getElementById('theme-select').value = data.theme; changeTheme(data.theme); }
                    if (data.bgValue) { document.getElementById('bg-select').value = data.bgValue; changeBackground(data.bgValue); }
                    if (data.paperSize) { document.getElementById('paper-size').value = data.paperSize; changePaperSize(data.paperSize); }
                    if (data.mode) window.setMode(data.mode);

                    if (Array.isArray(data.images)) {
                        window.groupImages.forEach(g => { if(g && g.url && g.url.startsWith('blob:')) URL.revokeObjectURL(g.url); });
                        window.groupImages = new Array(data.images.length).fill(null);
                        setTimeout(() => {
                            data.images.forEach((imgData, idx) => {
                                // Validate image data
                                if (imgData && imgData.b64 && typeof imgData.b64 === 'string' && imgData.b64.startsWith('data:')) {
                                    window.groupImages[idx] = { url: imgData.b64, canvasData: imgData.canvasData, cropBoxData: imgData.cropBoxData };
                                }
                            });
                            refreshGrid();
                        }, 100);
                    }

                    stampLayer.innerHTML = '';
                    if (Array.isArray(data.stamps)) {
                        data.stamps.forEach(s => {
                            if (s && s.text) {
                                createStamp(s.text, s.left, s.top, s.size, s.rotation, s.isText || false, s.font, s.color);
                            }
                        });
                    }

                    showToast('Project loaded successfully!');
                } catch (err) {
                    console.error('Project load error:', err);
                    showToast('Failed to load project - invalid or corrupted file');
                }
            };
            reader.readAsText(file); event.target.value = '';
        }

        window.saveOutput = async function() {
            const format = document.getElementById('export-format').value;
            const loadingOverlay = document.getElementById('loading-overlay'); loadingOverlay.style.display = 'flex';
            document.body.classList.add('printing'); 
            document.querySelectorAll('.stamp-wrapper').forEach(el => el.classList.remove('selected')); activeStamp = null;

            const cells = document.querySelectorAll('.cell'); const tempImages = [];
            let gifWorkerUrl = null;
            if(format === 'gif') {
                try {
                    const blob = await fetch('lib/gif.worker.js').then(r => r.blob());
                    gifWorkerUrl = URL.createObjectURL(blob);
                } catch(e) {
                    console.warn('GIF worker load failed, using direct path', e);
                    gifWorkerUrl = 'lib/gif.worker.js';
                }
            }

            if(format !== 'gif') {
                cells.forEach((cell, index) => {
                    const cropper = window.cropperInstances[index];
                    if (cropper) { 
                        // Get cropped canvas without forced dimensions to preserve actual crop
                        const canvas = cropper.getCroppedCanvas({ 
                            imageSmoothingQuality: 'high',
                            fillColor: '#fff'
                        });
                        if (canvas) {
                            const img = document.createElement('img'); 
                            img.src = canvas.toDataURL('image/png'); 
                            img.className = 'temp-print-image';
                            // Ensure styles are explicit
                            img.style.cssText = 'width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;';
                            
                            const container = cell.querySelector('.img-container'); 
                            const cropperDiv = container.querySelector('.cropper-container');
                            if(cropperDiv) cropperDiv.style.display = 'none'; 
                            container.appendChild(img); 
                            tempImages.push({ container, img, cropperDiv });
                        }
                    }
                });
            } else {
                cells.forEach((cell, index) => {
                    const cropper = window.cropperInstances[index];
                    if (cropper) {
                        const container = cell.querySelector('.img-container'); const sourceImg = container.querySelector('.source-image'); const cropperDiv = container.querySelector('.cropper-container');
                        const cropData = cropper.getData(); const containerRect = container.getBoundingClientRect(); const scale = containerRect.width / cropData.width;
                        const wrapper = document.createElement('div'); wrapper.style.cssText = 'width:100%;height:100%;overflow:hidden;position:relative;'; wrapper.className = 'temp-gif-wrapper';
                        const animImg = sourceImg.cloneNode(true); animImg.style.cssText = `display:block;position:absolute;width:${sourceImg.naturalWidth * scale}px;height:${sourceImg.naturalHeight * scale}px;left:${-cropData.x * scale}px;top:${-cropData.y * scale}px;max-width:none;max-height:none;`;
                        if (cell.classList.contains('weathered-active')) animImg.classList.add('temp-weathered');
                        if(cropperDiv) cropperDiv.style.display = 'none'; wrapper.appendChild(animImg); container.appendChild(wrapper); tempImages.push({ container, img: wrapper, cropperDiv }); 
                    }
                });
            }

            await new Promise(resolve => setTimeout(resolve, 800)); 

            try {
                if (format === 'gif') {
                    const gifOptions = { workers: 2, quality: 10, width: paperElement.offsetWidth * 1.5, height: paperElement.offsetHeight * 1.5 };
                    if (gifWorkerUrl) { gifOptions.workerScript = gifWorkerUrl; }
                    const gif = new GIF(gifOptions);
                    const frameCount = 15;
                    for (let i = 0; i < frameCount; i++) {
                         const canvas = await html2canvas(paperElement, { scale: 1.5, useCORS: true, logging: false, backgroundColor: null });
                         gif.addFrame(canvas, {delay: 100}); await new Promise(r => setTimeout(r, 100));
                    }
                    gif.on('finished', function(blob) {
                         const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = 'snap-station-stickers.gif'; link.href = url; link.click();
                         tempImages.forEach(item => { item.img.remove(); if (item.cropperDiv) item.cropperDiv.style.display = ''; });
                         if(gifWorkerUrl) URL.revokeObjectURL(gifWorkerUrl); loadingOverlay.style.display = 'none'; document.body.classList.remove('printing');
                    });
                    gif.render(); return; 
                }
                
                const canvas = await html2canvas(paperElement, { scale: 3, useCORS: true });
                if (format === 'pdf') {
                    const imgData = canvas.toDataURL('image/png'); const docStyle = getComputedStyle(document.documentElement);
                    const pW = parseFloat(docStyle.getPropertyValue('--paper-width')); const pH = parseFloat(docStyle.getPropertyValue('--paper-height'));
                    const orientation = pW > pH ? 'landscape' : 'portrait';
                    const pdf = new jspdf.jsPDF({ orientation: orientation, unit: 'mm', format: [pW, pH] });
                    pdf.addImage(imgData, 'PNG', 0, 0, pW, pH); pdf.save('snap-station-stickers.pdf');
                } else {
                    const mimeType = format === 'jpg' ? 'image/jpeg' : (format === 'webp' ? 'image/webp' : 'image/png');
                    canvas.toBlob(blob => {
                         const link = document.createElement('a'); link.download = `snap-station-stickers.${format}`;
                         link.href = URL.createObjectURL(blob); link.click(); URL.revokeObjectURL(link.href);
                    }, mimeType, 0.95);
                }
            } catch (error) {
                console.error('Export error:', error);
                const errorMsg = error.message.includes('canvas') ? 'Failed to generate output - image may be too large' : 'Failed to generate output - please try a different format';
                showToast(errorMsg);
            } finally {
                if (format !== 'gif') { tempImages.forEach(item => { item.img.remove(); if (item.cropperDiv) item.cropperDiv.style.display = ''; }); loadingOverlay.style.display = 'none'; document.body.classList.remove('printing'); }
            }
        }
        init();
    })();
</script>
<script>
    /* * ADVANCED PRINTER GAMEPAD SUPPORT 
     * Features: Spatial Nav, Analog Support, Contextual Modes, Grabbing
     */
    (function() {
        if (!window.navigator || !navigator.getGamepads) return;

        const PrinterGamepad = {
            gpIndex: null,
            lastButtons: [],
            focusedEl: null,
            elements: [],
            
            // Konami State
            konamiSeqGP: [12, 12, 13, 13, 14, 15, 14, 15, 1, 0, 9], // Up, Up, Down, Down, Left, Right, Left, Right, B, A, Start
            konamiIndexGP: 0,
            
            // State
            mode: 'MENU', // 'MENU', 'GRAB_STAMP'
            grabbedStamp: null,
            
            // Tuning
            deadzone: 0.5,
            navCooldown: 0,
            COOLDOWN_FRAMES: 8,
            moveSpeed: 5,

            // Visuals
            indicatorEl: document.getElementById('gp-mode-text'),
            indicatorContainer: document.getElementById('gp-indicator'),

            init: function() {
                window.addEventListener("gamepadconnected", (e) => { 
                    this.gpIndex = e.gamepad.index; 
                    this.startPolling(); 
                    this.showIndicator("Controller Connected");
                    this.refreshElements();
                    this.focusBestInitial();
                });
                window.addEventListener("gamepaddisconnected", (e) => { 
                    if (this.gpIndex === e.gamepad.index) { 
                        this.gpIndex = null; 
                        this.hideIndicator(); 
                    } 
                });
            },

            showIndicator: function(msg) {
                if(this.indicatorEl) this.indicatorEl.textContent = msg;
                if(this.indicatorContainer) this.indicatorContainer.classList.add('visible');
            },

            hideIndicator: function() {
                if(this.indicatorContainer) this.indicatorContainer.classList.remove('visible');
            },

            refreshElements: function() {
                // Gather all interactive elements
                const selectors = [
                    ".controls button", 
                    ".controls select", 
                    ".controls input", 
                    ".file-input-wrapper",
                    ".stamp-wrapper", // Stamps are navigable
                    ".modal-close",
                    "button[onclick*='downloadCuttingTemplate']"
                ];
                // Filter visible only
                this.elements = Array.from(document.querySelectorAll(selectors.join(",")))
                    .filter(el => {
                        const style = window.getComputedStyle(el);
                        return style.display !== 'none' && style.visibility !== 'hidden' && !el.disabled && el.offsetParent !== null;
                    });
            },

            focusBestInitial: function() {
                if (this.elements.length > 0) {
                    this.setFocus(this.elements[0]);
                }
            },

            setFocus: function(el) {
                if (this.focusedEl) {
                    this.focusedEl.classList.remove('gamepad-focus');
                    // Close stamp controls if leaving a stamp
                    if(this.focusedEl.classList.contains('stamp-wrapper')) {
                        this.focusedEl.classList.remove('selected');
                    }
                }
                this.focusedEl = el;
                if (this.focusedEl) {
                    this.focusedEl.classList.add('gamepad-focus');
                    this.focusedEl.focus({preventScroll: true});
                    this.focusedEl.scrollIntoView({behavior: 'smooth', block: 'center'});
                    
                    // Stamp Logic
                    if(this.focusedEl.classList.contains('stamp-wrapper')) {
                        this.focusedEl.classList.add('selected');
                        this.showIndicator("Stamp Selected (Press A to Grab)");
                    } else {
                        this.showIndicator("Menu Mode");
                    }
                }
            },

            startPolling: function() {
                const loop = () => {
                    if (this.gpIndex !== null) {
                        this.checkInput();
                        requestAnimationFrame(loop);
                    }
                };
                requestAnimationFrame(loop);
            },

            checkInput: function() {
                const gp = navigator.getGamepads()[this.gpIndex];
                if (!gp) return;

                // Konami Check
                this.checkKonami(gp);

                // 1. Context Switching (Grab Mode vs Menu Mode)
                if (this.mode === 'GRAB_STAMP' && this.grabbedStamp) {
                    this.handleGrabInput(gp);
                } else {
                    this.handleMenuInput(gp);
                }

                this.lastButtons = gp.buttons.map(b => ({ pressed: b.pressed }));
            },

            checkKonami: function(gp) {
                let pressedBtn = -1;
                for(let i=0; i<gp.buttons.length; i++) {
                    if (this.justPressed(gp, i)) {
                        pressedBtn = i;
                        break;
                    }
                }

                if (pressedBtn !== -1) {
                    if (pressedBtn === this.konamiSeqGP[this.konamiIndexGP]) {
                        this.konamiIndexGP++;
                        if (this.konamiIndexGP === this.konamiSeqGP.length) {
                            if(window.unlock1UpTheme) window.unlock1UpTheme();
                            this.konamiIndexGP = 0;
                        }
                    } else {
                        this.konamiIndexGP = 0; 
                         if (pressedBtn === this.konamiSeqGP[0]) {
                            this.konamiIndexGP = 1;
                        }
                    }
                }
            },

            handleMenuInput: function(gp) {
                // Cooldown for nav
                if (this.navCooldown > 0) this.navCooldown--;

                // --- Directional Input (D-Pad + Analog) ---
                let dx = 0, dy = 0;
                
                // D-Pad
                if (gp.buttons[12].pressed) dy = -1; // Up
                if (gp.buttons[13].pressed) dy = 1;  // Down
                if (gp.buttons[14].pressed) dx = -1; // Left
                if (gp.buttons[15].pressed) dx = 1;  // Right

                // Analog Stick (Axis 0, 1) with Deadzone
                if (Math.abs(gp.axes[0]) > this.deadzone) dx = gp.axes[0];
                if (Math.abs(gp.axes[1]) > this.deadzone) dy = gp.axes[1];

                // Execute Move if Cooldown ready and input exists
                if (this.navCooldown === 0 && (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5)) {
                    this.moveFocusGeometric(dx, dy);
                    this.navCooldown = this.COOLDOWN_FRAMES;
                }

                // --- Buttons ---
                // A (0) - Select / Grab
                if (this.justPressed(gp, 0)) {
                    if (this.focusedEl) {
                        if (this.focusedEl.classList.contains('stamp-wrapper')) {
                            // Enter Grab Mode
                            this.mode = 'GRAB_STAMP';
                            this.grabbedStamp = this.focusedEl;
                            this.grabbedStamp.classList.add('grabbed');
                            this.showIndicator("Grabbing Stamp (A to Drop, B to Delete)");
                        } else {
                            // Normal Click
                            this.focusedEl.click();
                        }
                    }
                }

                // B (1) - Back / Close Modal
                if (this.justPressed(gp, 1)) {
                    const visibleModal = document.querySelector('.modal-overlay[style*="display: flex"]');
                    if (visibleModal) {
                        // Find close button
                        const closeBtn = visibleModal.querySelector('.modal-close');
                        if (closeBtn) closeBtn.click();
                    } else if (this.focusedEl && this.focusedEl.classList.contains('stamp-wrapper')) {
                         // Deselect Stamp
                         this.focusedEl.classList.remove('selected');
                         // Find nearest non-stamp element to retreat to? Or just stay focused.
                    }
                }
            },

            handleGrabInput: function(gp) {
                // Movement logic for Stamp
                let dx = 0, dy = 0;
                
                // D-Pad
                if (gp.buttons[12].pressed) dy = -1;
                if (gp.buttons[13].pressed) dy = 1;
                if (gp.buttons[14].pressed) dx = -1;
                if (gp.buttons[15].pressed) dx = 1;

                // Analog
                if (Math.abs(gp.axes[0]) > this.deadzone) dx = gp.axes[0];
                if (Math.abs(gp.axes[1]) > this.deadzone) dy = gp.axes[1];

                // Chording: Hold L1 (Btn 4) to speed up
                let speed = this.moveSpeed;
                if (gp.buttons[4].pressed) speed *= 3; 

                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                    const rect = this.grabbedStamp.getBoundingClientRect();
                    const parentRect = this.grabbedStamp.offsetParent.getBoundingClientRect();
                    
                    // Convert current left/top to pixels relative to parent
                    let currentLeft = parseFloat(this.grabbedStamp.style.left) || (rect.left - parentRect.left);
                    let currentTop = parseFloat(this.grabbedStamp.style.top) || (rect.top - parentRect.top);

                    this.grabbedStamp.style.left = (currentLeft + dx * speed) + 'px';
                    this.grabbedStamp.style.top = (currentTop + dy * speed) + 'px';
                }

                // A (0) - Drop
                if (this.justPressed(gp, 0)) {
                    this.mode = 'MENU';
                    this.grabbedStamp.classList.remove('grabbed');
                    this.grabbedStamp = null;
                    this.showIndicator("Stamp Dropped");
                }

                // B (1) - Delete
                if (this.justPressed(gp, 1)) {
                    this.grabbedStamp.remove();
                    this.mode = 'MENU';
                    this.grabbedStamp = null;
                    this.refreshElements();
                    this.focusBestInitial();
                    this.showIndicator("Stamp Deleted");
                }
            },

            // --- Geometric Navigation Logic ---
            moveFocusGeometric: function(dx, dy) {
                this.refreshElements(); // Ensure list is up to date
                
                if (!this.focusedEl) {
                    this.focusBestInitial();
                    return;
                }

                const currentRect = this.focusedEl.getBoundingClientRect();
                const cx = currentRect.left + currentRect.width / 2;
                const cy = currentRect.top + currentRect.height / 2;

                let bestCandidate = null;
                let minScore = Infinity;

                // Normalize direction vector
                const mag = Math.sqrt(dx*dx + dy*dy);
                const ndx = dx / mag;
                const ndy = dy / mag;

                for (let el of this.elements) {
                    if (el === this.focusedEl) continue;

                    const rect = el.getBoundingClientRect();
                    const tcx = rect.left + rect.width / 2;
                    const tcy = rect.top + rect.height / 2;

                    // Vector to target
                    const vbx = tcx - cx;
                    const vby = tcy - cy;
                    const dist = Math.sqrt(vbx*vbx + vby*vby);

                    // Project vector onto direction (Dot Product)
                    const dot = vbx * ndx + vby * ndy;

                    // Must be in the general direction (dot product > 0)
                    // We can be stricter (e.g., > 0.5) to prevent moving sideways when pressing up
                    if (dot <= 0) continue; 

                    // Calculate perpendicular distance (rejection)
                    // How far "off track" is this element?
                    // We want elements close to the movement axis.
                    // Rejection vector magnitude:
                    // dist^2 = dot^2 + rej^2  => rej^2 = dist^2 - dot^2
                    const rejSq = (dist*dist) - (dot*dot);
                    
                    // Score: We want low distance, high alignment
                    // Weight perpendicular distance heavily
                    const score = dist + (rejSq * 2); 

                    if (score < minScore) {
                        minScore = score;
                        bestCandidate = el;
                    }
                }

                if (bestCandidate) {
                    this.setFocus(bestCandidate);
                }
            },

            justPressed: function(gp, btnIndex) {
                return gp.buttons[btnIndex].pressed && !(this.lastButtons[btnIndex] && this.lastButtons[btnIndex].pressed);
            }
        };

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", () => PrinterGamepad.init());
        } else {
            PrinterGamepad.init();
        }
    })();
</script>
</body>
</html>